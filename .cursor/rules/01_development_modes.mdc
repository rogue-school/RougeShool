---
alwaysApply: false
description: "Development modes reference: Prototyping vs Refactoring - AI adapts code quality based on development phase (reference when user mentions mode keywords)"
---

# RougeShool Development Modes

## ğŸ“– Overview

> **Important**: Solo development follows a prototyping â†’ refactoring cycle.
> AI adapts code quality based on the user's specified development phase.

---

## ğŸš€ Mode 1: Prototyping Mode

### Purpose
```
Rapid implementation and idea validation
â†’ Working code > Perfect structure
```

### Allowed Practices
```
âœ… Some code duplication (will refactor later)
âœ… Simple structure (skip complex patterns)
âœ… TODO comments allowed
âœ… Minimal error handling (null checks, basic try-catch)
âœ… Hardcoded values (will move to ScriptableObject later)
âœ… Simple logic (optimize later)
```

### Still Prohibited
```
âŒ Singleton pattern
âŒ FindObjectOfType
âŒ Skipping Korean logging
âŒ Compilation errors/warnings
```

### User Request Examples
```
"ì¼ë‹¨ ì  AI ë¹¨ë¦¬ ë§Œë“¤ì–´ì¤˜" (Just make enemy AI quickly)
"í”„ë¡œí† íƒ€ì…ìœ¼ë¡œ ì¹´ë“œ ë“œë˜ê·¸ êµ¬í˜„í•´ì¤˜" (Implement card drag as prototype)
"ë¹ ë¥´ê²Œ ë³´ìŠ¤ íŒ¨í„´ ë§Œë“¤ì–´ì¤˜. ë‚˜ì¤‘ì— ì •ë¦¬í• ê±°ì•¼" (Quick boss pattern, will clean up later)
"ë™ì‘ë§Œ í•˜ë©´ ë¼. êµ¬ì¡°ëŠ” ì‹ ê²½ ì•ˆì¨ë„ ë¼" (Just make it work, don't worry about structure)
```

### Code Quality Characteristics
```
Prototyping Mode Code Quality:
â”œâ”€â”€ SOLID principles: 50% (basic interfaces only)
â”œâ”€â”€ Code duplication: Allowed
â”œâ”€â”€ Error handling: Level 1 (Validation only)
â”œâ”€â”€ Comments: TODO allowed
â”œâ”€â”€ Performance optimization: None
â”œâ”€â”€ Pattern application: Minimal
â””â”€â”€ Development speed: Very fast âš¡âš¡âš¡
```

---

## ğŸ—ï¸ Mode 2: Refactoring Mode

### Purpose
```
Improve code structure and clean up architecture
â†’ Perfect structure > Fast implementation
```

### Requirements
```
âœ… SOLID principles 100% applied
âœ… Complete removal of code duplication
âœ… Remove unused/dead code
âœ… Introduce interfaces/abstractions
âœ… Perfect Zenject DI application
âœ… Complete 3-Tier error handling
âœ… Performance optimization (pooling, caching)
âœ… Complete XML documentation
```

### Tasks Performed
```
Code consolidation:
â”œâ”€â”€ Multiple duplicate code â†’ Single reusable class
â””â”€â”€ Similar logic â†’ Common base class/interface

Code separation:
â”œâ”€â”€ One large class â†’ Multiple responsibilities
â””â”€â”€ God Class â†’ Apply SRP

Pattern application:
â”œâ”€â”€ State Pattern (state management)
â”œâ”€â”€ Strategy Pattern (algorithm switching)
â”œâ”€â”€ Factory Pattern (object creation)
â”œâ”€â”€ Observer Pattern (event system)
â””â”€â”€ Command Pattern (undo functionality)

Performance optimization:
â”œâ”€â”€ Object Pooling
â”œâ”€â”€ Caching strategy
â”œâ”€â”€ GC minimization
â””â”€â”€ Update() optimization
```

### User Request Examples
```
"ì  AI ì‹œìŠ¤í…œ ë¦¬íŒ©í† ë§í•´ì¤˜. State Pattern ì ìš©" (Refactor enemy AI system, apply State Pattern)
"ì „íˆ¬ ì‹œìŠ¤í…œ ì „ì²´ ë¦¬íŒ©í† ë§. Manager ë¶„ë¦¬í•˜ê³  SOLID ì ìš©" (Full combat system refactor, separate managers and apply SOLID)
"ì¹´ë“œ ì‹œìŠ¤í…œ ì •ë¦¬í•´ì¤˜. ì¤‘ë³µ ì½”ë“œ ì œê±°í•˜ê³  êµ¬ì¡° ê°œì„ " (Clean up card system, remove duplicates and improve structure)
"ì´ ì½”ë“œ ë¦¬íŒ©í† ë§. ì¸í„°í˜ì´ìŠ¤ ë„ì…í•˜ê³  DI ì ìš©" (Refactor this code, introduce interfaces and apply DI)
"ì„±ëŠ¥ ìµœì í™” í•´ì¤˜. í’€ë§ ì ìš©í•˜ê³  GC ì¤„ì—¬ì¤˜" (Optimize performance, apply pooling and reduce GC)
```

### Code Quality Characteristics
```
Refactoring Mode Code Quality:
â”œâ”€â”€ SOLID principles: 100% (perfect structure)
â”œâ”€â”€ Code duplication: 0%
â”œâ”€â”€ Error handling: 3-Tier complete
â”œâ”€â”€ Comments: Remove TODO, complete XML
â”œâ”€â”€ Performance optimization: Complete
â”œâ”€â”€ Pattern application: Aggressive
â””â”€â”€ Development speed: Slow (careful) ğŸŒ
```

---

## ğŸ”„ Recommended Development Cycle

### Phase 1: Prototyping (1-2 weeks)
```
Goal: Create working prototype

"ì  ê¸°ë³¸ AI ë§Œë“¤ì–´ì¤˜" (Make basic enemy AI)
â””â”€â”€ Simple FSM implementation âœ…

"ì¹´ë“œ ì‹œìŠ¤í…œ ë§Œë“¤ì–´ì¤˜" (Make card system)
â””â”€â”€ Basic drag/drop only âœ…

"UI ë§Œë“¤ì–´ì¤˜" (Make UI)
â””â”€â”€ Essential screens only âœ…

Result: Playable prototype ğŸ®
```

### Phase 2: Refactoring (1 week)
```
Goal: Build clean architecture

"ì  AI ë¦¬íŒ©í† ë§. State Pattern ì ìš©" (Refactor enemy AI, apply State Pattern)
â””â”€â”€ FSM â†’ State Pattern conversion âœ…

"ì¹´ë“œ ì‹œìŠ¤í…œ ë¦¬íŒ©í† ë§. Factory Pattern ì ìš©" (Refactor card system, apply Factory Pattern)
â””â”€â”€ Remove duplicates, introduce Factory âœ…

"UI ë¦¬íŒ©í† ë§. ì¤‘ë³µ ì½”ë“œ ì œê±°" (Refactor UI, remove duplicates)
â””â”€â”€ Create common UI base class âœ…

Result: Extensible structure ğŸ—ï¸
```

### Phase 3: Prototyping Again (new features)
```
Goal: Quickly add new features

"ë³´ìŠ¤ íŒ¨í„´ ì¶”ê°€í•´ì¤˜" (Add boss patterns)
â””â”€â”€ Simple implementation âœ…

"ì•„ì´í…œ ì‹œìŠ¤í…œ ì¶”ê°€í•´ì¤˜" (Add item system)
â””â”€â”€ Just make it work âœ…

Result: Feature expansion complete ğŸ†•
```

### Phase 4: Refactoring Again
```
Goal: Consolidate entire system

"ì „ì²´ ì‹œìŠ¤í…œ í†µí•© ë¦¬íŒ©í† ë§" (Refactor entire system integration)
â””â”€â”€ Integrate boss/item systems into existing structure âœ…

Result: Completed game ğŸ¯
```

---

## ğŸ¯ Mode Comparison Examples

### Same Request, Different Results

#### Request: "ì  AI ë§Œë“¤ì–´ì¤˜" (Make enemy AI)

**Prototyping Mode Response:**
```csharp
// Simple implementation (50 lines)
public class EnemyAI : MonoBehaviour
{
    private enum State { Idle, Chase, Attack }
    private State currentState = State.Idle;

    void Update()
    {
        switch (currentState)
        {
            case State.Idle:
                // TODO: Detect player
                break;
            case State.Chase:
                // Simple chase logic
                transform.position = Vector3.MoveTowards(
                    transform.position,
                    player.position,
                    speed * Time.deltaTime
                );
                break;
            case State.Attack:
                // TODO: Attack logic
                break;
        }
    }
}
```

**Refactoring Mode Response:**
```csharp
// Perfect structure (200 lines + interfaces)

/// <summary>
/// ì  AI ìƒíƒœ ê´€ë¦¬ ì¸í„°í˜ì´ìŠ¤
/// </summary>
public interface IEnemyState
{
    void Enter(EnemyAI enemy);
    void Execute(EnemyAI enemy);
    void Exit(EnemyAI enemy);
}

/// <summary>
/// ì  AI ì»¨íŠ¸ë¡¤ëŸ¬ (State Pattern ì ìš©)
/// </summary>
public class EnemyAI : MonoBehaviour
{
    [Inject] private IPlayerCharacter player;

    private IEnemyState currentState;
    private Dictionary<Type, IEnemyState> states;

    [Inject]
    public void Construct(IPlayerCharacter player)
    {
        this.player = player ?? throw new ArgumentNullException(nameof(player));
    }

    private void Awake()
    {
        InitializeStates();
    }

    private void InitializeStates()
    {
        states = new Dictionary<Type, IEnemyState>
        {
            { typeof(IdleState), new IdleState() },
            { typeof(ChaseState), new ChaseState() },
            { typeof(AttackState), new AttackState() }
        };

        TransitionTo<IdleState>();
    }

    public void TransitionTo<T>() where T : IEnemyState
    {
        var newState = states[typeof(T)];

        currentState?.Exit(this);
        currentState = newState;
        currentState.Enter(this);

        GameLogger.LogInfo($"ìƒíƒœ ì „í™˜: {typeof(T).Name}", GameLogger.LogCategory.AI);
    }

    private void Update()
    {
        currentState?.Execute(this);
    }
}

// IdleState, ChaseState, AttackState classes...
```

---

## ğŸ“Š Automatic Mode Detection

### AI Automatically Detects Mode from Keywords

```
Switch to Prototyping Mode:
â”œâ”€â”€ "ì¼ë‹¨" (just/first), "ë¹¨ë¦¬" (quickly), "ë¹ ë¥´ê²Œ" (fast)
â”œâ”€â”€ "í”„ë¡œí† íƒ€ì…" (prototype), "í”„ë¡œí† íƒ€ì…ìœ¼ë¡œ" (as prototype)
â”œâ”€â”€ "ë‚˜ì¤‘ì— ì •ë¦¬" (clean up later), "ë‚˜ì¤‘ì— ë¦¬íŒ©í† ë§" (refactor later)
â”œâ”€â”€ "ë™ì‘ë§Œ" (just make it work), "ì¼ë‹¨ ëŒì•„ê°€ê²Œ" (just make it run)
â””â”€â”€ "TODO í—ˆìš©" (allow TODO)

Switch to Refactoring Mode:
â”œâ”€â”€ "ë¦¬íŒ©í† ë§" (refactor), "ì •ë¦¬" (clean up)
â”œâ”€â”€ "êµ¬ì¡° ê°œì„ " (improve structure), "ì•„í‚¤í…ì²˜" (architecture)
â”œâ”€â”€ "SOLID ì ìš©" (apply SOLID), "íŒ¨í„´ ì ìš©" (apply patterns)
â”œâ”€â”€ "ì¤‘ë³µ ì œê±°" (remove duplicates), "ìµœì í™”" (optimize)
â””â”€â”€ "ì™„ë²½í•˜ê²Œ" (perfectly), "ê¹”ë”í•˜ê²Œ" (cleanly)

Default Mode (when not specified):
â”œâ”€â”€ Balanced quality
â”œâ”€â”€ SOLID 70% applied
â””â”€â”€ Moderate speed
```

---

## âš ï¸ Warnings

### Prototyping Mode Risks
```
âš ï¸ Using only Prototyping Mode for too long:
â”œâ”€â”€ Technical debt accumulation
â”œâ”€â”€ Refactoring becomes impossible later
â””â”€â”€ Codebase becomes unmaintainable

Recommendation: Perform refactoring phase every 2-3 weeks
```

### Refactoring Mode Risks
```
âš ï¸ Using only Refactoring Mode from start:
â”œâ”€â”€ Development speed too slow
â”œâ”€â”€ Vulnerable to requirement changes
â””â”€â”€ Over-engineering

Recommendation: First validate with prototyping, then refactor
```

---

## âœ… Usage Guide

### Starting Prototyping
```
User: "ì¼ë‹¨ ë³´ìŠ¤ íŒ¨í„´ ë¹¨ë¦¬ ë§Œë“¤ì–´ì¤˜. ë‚˜ì¤‘ì— ì •ë¦¬í• ê±°ì•¼"
AI: "Implementing quickly in Prototyping Mode"
â†’ Simple structure, TODO allowed, fast implementation
```

### Starting Refactoring
```
User: "ë³´ìŠ¤ íŒ¨í„´ ì‹œìŠ¤í…œ ë¦¬íŒ©í† ë§í•´ì¤˜. State Pattern ì ìš©í•˜ê³  êµ¬ì¡° ê°œì„ "
AI: "Creating perfect structure in Refactoring Mode"
â†’ Apply SOLID, remove duplicates, introduce patterns
```

### Switching Modes
```
User: "í”„ë¡œí† íƒ€ì´í•‘ ëª¨ë“œë¡œ ì „í™˜"
AI: "Switching to Prototyping Mode. Focusing on fast implementation"

User: "ë¦¬íŒ©í† ë§ ëª¨ë“œë¡œ ì „í™˜"
AI: "Switching to Refactoring Mode. Focusing on perfect structure"
```

---

## ğŸ‰ Conclusion

**Your development approach is optimized for solo development!**

```
Prototyping â†’ Validation â†’ Refactoring â†’ Prototyping again...

This cycle is the key to successful solo development.
AI now generates appropriate code based on your development phase.
```
