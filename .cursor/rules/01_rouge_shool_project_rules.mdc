---
description: "Unity 2D 개발 표준(아키텍처/DI/리팩토링/Git/품질 게이트, Cursor 연동)"
globs: ["**/*.cs", "**/*.unity", "**/*.prefab", "**/*.md"]
rule_id: rouge_shool_project_rules
version: 1.2.0
alwaysApply: true
---

# RougeShool Unity 2D 프로젝트 규칙 (Production)

> 목적: Unity 6000.0.42f1, 2D Built-in Pipeline 기준으로 실전 개발 품질/속도/안정성을 보장한다. 모든 규칙은 즉시 적용 가능해야 하며, 문서·코드·씬에 일관되게 반영한다.

## 1) 우선순위
1. 🔥 핵심 필수 규칙
2. 🚫 예시 코드 금지 규칙
3. 🧠 체계적 사고 과정
4. 🤖 AI 코드 생성 규칙(Cursor 통합)
5. 🎨 플러그인 활용 규칙(DOTween/Zenject)
6. 🏗️ CoreScene 자동화
7. ⚡ 성능 최적화(2D)
8. 💡 Unity 6 특화

## 2) 기본 개발 원칙
- 모든 주석/문서/로그는 한국어.
- `GameLogger`를 사용해 로그 레벨별 로깅(Info/Warning/Error).
- TextMeshPro 우선 사용.
- 아키텍처/네임스페이스/폴더 구조 일치.
- 공용 시스템(CoreSystem)은 전역, 씬별 로직은 씬에 한정.

## 3) 핵심 필수 규칙
- 공개 메서드: null/범위 검증 + 예외 처리(ArgumentNullException/InvalidOperationException).
- 기존 코드/자산 재사용 우선, 중복 금지.
- 즉시 적용 가능한 변경은 즉시 수행, 대규모는 설계/영향도 제시 후 진행.
- 변경 시 관련 문서/씬 문서 동기화 및 Delta 기록.

## 4) AI 코드 생성 규칙(Cursor 도구/API 명세 포함)
- **기존 코드 분석 우선**: 모든 코드 생성 전 반드시 기존 코드 검색 및 분석
- **중복 방지**: 동일/유사 기능이 존재하면 기존 코드 재사용/확장 우선
- **기존 코드 수정 우선**: 새로 생성하기보다는 기존 코드 수정/개선 방향으로 진행
- **명칭 일관성**: 기존 프로젝트의 네이밍 컨벤션과 일치하는지 확인
- **도구 사용 순서**: codebase_search(광역) → grep(정확) → read_file(세부) → search_replace/MultiEdit(수정)
- **품질 보장**: read_lints로 경고/오류 0 확인, 한국어 로깅, XML 문서화
- **병렬화**: 독립 검색/읽기는 병렬 실행으로 효율성 극대화
- **금지**: 샘플/예시 코드, 더미 데이터, 중복 기능 생성

## 5) 아키텍처·디자인 패턴
- 모듈 구조 유지(CombatSystem/SkillCardSystem 등).
- 싱글톤 매니저는 `Instance` + `Awake` 초기화, 전역은 CoreScene에만 존재.
- DI 적용(Zenject): 인터페이스 기반 설계, Installer에 명시.
- 이벤트 기반(옵저버/전략) + 상태 기반 로직.
- Factory/Helper/Controller 접미사 규칙.

## 5-α) 플러그인 활용 규칙(DOTween Pro/Zenject)
- **DOTween Pro 우선 사용**: 모든 애니메이션은 코루틴 대신 DOTween Pro 사용 (전문적 활용 규칙 적용).
- **체인 애니메이션**: `.SetEase()`, `.OnComplete()`, `.SetDelay()` 등 고급 기능 활용.
- **애니메이션 풀링**: `DOTween.SetTweensCapacity()`로 성능 최적화.
- **SafeMode 설정**: 안정성을 위해 DOTween SafeMode 활성화 유지.
- **애니메이션 매니저**: DOTweenAnimationManager를 통한 체계적 애니메이션 관리.
- **팩토리 패턴**: DOTweenAnimationFactory를 통한 재사용 가능한 애니메이션 생성.
- **Zenject DI 의무화**: 모든 매니저는 Zenject로 DI 설정, 싱글톤 대신 컨테이너 활용.
- **인터페이스 기반**: DI 바인딩은 인터페이스 기반으로 테스트 가능성 확보.
- **Installer 패턴**: 각 시스템별 Installer 클래스로 DI 설정 중앙화.
- **생명주기 관리**: Zenject의 `AsSingle()`, `NonLazy()` 등 적절한 스코프 설정.
- **AnimationSystem 제거**: 모든 AnimationSystem 관련 코드 제거 완료, DOTween Pro 기반 재구현 준비.

## 6) 폴더·네임스페이스 규칙
```
Assets/Script/
  CoreSystem/
  CombatSystem/
  SkillCardSystem/
  ...
```
- 폴더 = 네임스페이스. 파일 이동은 `git mv` 또는 IDE 이동으로 이력 보존.

## 7) 성능 최적화(2D)
- Sprite Atlas로 Draw Call 최소화.
- Update 최소화, 가능 시 async/await 선호.
- 2D Physics만 사용, FixedUpdate 적절 활용.
- UI 업데이트는 필요한 경우에만.
- **DOTween Pro 최적화**: 애니메이션 풀링으로 GC 압박 최소화, SetTweensCapacity로 성능 최적화.
- **Zenject 최적화**: DI 컨테이너로 객체 생성 비용 절약.
- **애니메이션 이벤트**: Update() 대신 DOTween 이벤트 콜백 활용.
- **SafeMode 활용**: DOTween SafeMode로 안정성 보장.

## 8) 리팩토링 규칙
- 새 기능 전 유사 코드 탐색 → 재사용/개선.
- 불필요한 코드는 제거(주석 처리 금지). 네이밍/타입 일관 리네임 일괄 적용.
- 단계별 변경, 단위 테스트/수동 테스트 포함.

## 9) Git 협업
- 삭제/재생성 대신 이동. 대규모 리네임은 원자적 커밋.
- 브랜치 전략 준수, PR에 영향도 및 문서 링크 포함.

## 10) CoreScene 자동화
- 전역 시스템만 포함. `CoreSystemInitializer`로 초기화 순서 통제.
- `DontDestroyOnLoad` 준수. Audio/UI 자동 바인딩 시스템 사용.
- CoreScene 변경 시 씬 문서/체크리스트 동기화.

## 11) 에러 처리·안정성
- 심각 오류: `GameLogger.Error`, 경고: `Warning`, 정보: `Info`.
- 복구 가능 시 사용자 피드백 제공, 실패 시 안전 종료 절차.

## 12) 검사·품질 게이트
- 컴파일 경고 0, 린터 0, 씬/문서 체크리스트 100%.
- 공개 API XML 주석, 주요 메서드 한국어 주석.
- **DOTween Pro 검증**: SafeMode 활성화, 애니메이션 풀링 설정 확인, SetTweensCapacity 최적화 확인.
- **Zenject 검증**: DI 바인딩 완전성, 인터페이스 구현 확인.
- **성능 검증**: DOTween Pro 이벤트 기반 애니메이션, Update 최소화 확인.
- **애니메이션 매니저 검증**: DOTweenAnimationManager 정상 동작, 트윈 정리 확인.
 - 신규 스크립트 생성 시: 기존 유사 스크립트 검색 증빙(검색어/대상/결론) 포함.

## 14) Cursor 도구 목록(참조)
- read_file / list_dir / glob_file_search / codebase_search / grep
- edit_file / apply_patch / delete_file
- read_lints / todo_write
- run_terminal_cmd / web_search / update_memory / edit_notebook
- multi_tool_use.parallel

## 13) 변경 기록(Delta)
- 형식: `YYYY-MM-DD | 작성자 | 변경 요약 | 영향도(코드/씬/문서)`

예)
- 2025-09-09 | Maintainer | 규칙 정리 및 Cursor 통합 규정 추가 | 문서
- 2025-09-09 | Maintainer | Cursor 도구/API 명세 및 병렬화 규칙 추가 | 문서
- 2025-09-09 | Maintainer | Cursor Rules 프론트매터(Always 적용) 추가 | 문서
- 2025-01-27 | Maintainer | DOTween/Zenject 플러그인 활용 규칙 추가 | 문서
- 2025-01-27 | Maintainer | AnimationSystem 완전 제거 및 임시 처리 규칙 추가 | 문서
- 2025-01-27 | Maintainer | DOTween Pro 전문 활용 규칙 추가 및 플러그인 규칙 업데이트 | 문서


## 📋 기본 개발 원칙
- 모든 주석, 문서, 로그 메시지는 한국어로 작성해야 함
- GameLogger를 사용하여 Debug.Log 대신 카테고리별 로깅을 해야 함
- 전문적이지만 실용적인 코드 구조로 높은 품질을 유지해야 함
- 기획 변경에 대응할 수 있는 유연하고 수정 가능한 코드를 작성해야 함
- 텍스트 UI는 기본 Text 대신 TextMeshPro를 사용해야 함
- CoreScene은 전역 시스템만 포함하고 씬별 로직은 제외해야 함
- CoreSystem 스크립트는 자동 초기화 시스템을 통해 관리해야 함

## 🔥 핵심 필수 규칙 (최우선 - 반드시 적용)
- 코드 생성 전 간단한 수정은 즉시 적용, 복잡한 기능은 사용자 확인 후 진행해야 함
- 사용자가 명시적으로 "예시 코드 생성"을 요청하지 않는 한 예시 코드를 생성하지 않음
- 기존 코드와의 중복 여부를 먼저 검토하고 기존 코드 재사용을 우선함
- 모든 public 메서드에서 매개변수 null 체크 및 유효성 검증을 구현해야 함
- 모든 public 메서드에서 예외 처리를 구현해야 함
- Unity 2D 게임 개발 속도를 최우선으로 고려한 코드를 작성해야 함
- 프로젝트 전체 아키텍처와 일관된 코드를 생성해야 함
- 기획 변경에 대응할 수 있는 유연한 구조로 설계해야 함

## 🚫 예시 코드 생성 방지 규칙 (최우선 - 반드시 적용)
- 사용자가 명시적으로 "예시 코드 생성" 또는 "샘플 코드 작성"을 요청하지 않는 한 절대 예시 코드를 생성하지 않음
- 설명이나 설명을 위한 코드 블록을 생성하지 않음
- "이런 식으로 구현할 수 있습니다"와 같은 설명용 코드를 생성하지 않음
- 실제 프로젝트에 사용할 수 있는 완전한 코드만 생성해야 함
- 코드 설명이 필요한 경우 주석이나 문서로만 설명해야 함
- 예시나 샘플 목적의 불완전한 코드를 생성하지 않음
- 사용자가 "예시를 보여줘"라고 명시적으로 요청한 경우에만 예시 코드를 생성해야 함
- 모든 생성된 코드는 즉시 프로젝트에 적용 가능한 완성된 형태여야 함
- 코드 블록 내에 "// 예시 코드" 또는 "// 샘플" 같은 주석이 포함된 코드를 생성하지 않음
- 설명용 더미 데이터나 테스트용 변수명을 사용하지 않음

## 🧠 체계적 사고 과정 규칙 (필수 - 코드 생성 전 적용)
- 코드 생성 전에 반드시 다음 사고 과정을 거쳐야 함
- 1단계: 요구사항을 분석하고 문제를 정의해야 함
- 2단계: 기존 시스템을 분석하고 영향도를 평가해야 함
- 3단계: 아키텍처를 설계하고 패턴을 선택해야 함
- 4단계: 의존성 및 인터페이스를 설계해야 함
- 5단계: 예외 상황 및 에지 케이스를 고려해야 함
- 6단계: 성능 및 메모리 최적화 방안을 검토해야 함
- 7단계: 테스트 가능성 및 유지보수성을 평가해야 함
- 8단계: 최종 설계를 검증하고 사용자 승인을 요청해야 함
- 각 단계별로 구체적인 분석 결과와 근거를 제시해야 함
- 사고 과정에서 발견된 문제점이나 개선사항을 명확히 보고해야 함

## 🤖 AI 코드 생성 규칙 (필수 - 모든 코드 생성 시 적용)
- Unity 2D 게임 개발 속도를 최우선으로 고려한 코드를 생성해야 함
- 간단한 수정은 즉시 적용, 복잡한 기능은 목적 설명 후 사용자 확인을 받아야 함
- 기존 코드와의 중복 여부를 먼저 검토하고 보고해야 함
- 새로운 기능 추가 시 기존 시스템과의 연동 방안을 제시해야 함
- Unity 2D Built-in Render Pipeline에 최적화된 코드를 생성해야 함
- 프로젝트 목적에 맞지 않는 불필요한 변수나 함수를 생성하지 않음
- 필요한 변수와 함수를 먼저 추천하고 사용자 확인 후 생성해야 함
- 사용자가 명시적으로 요청하지 않은 기능은 추가하지 않음
- 생성된 코드는 바로 Unity 2D 프로젝트에 적용할 수 있는 완성된 형태여야 함
- 기획 변경 시 쉽게 수정할 수 있는 구조로 설계해야 함
- 대규모 리팩토링 시에도 안전하게 수정 가능한 구조로 설계해야 함

## 🎯 Cursor AI 특화 기능 활용 규칙 (필수 - Cursor 기능 활용 시 적용)
- 현재 열린 파일과 커서 위치를 고려한 정확한 코드를 생성해야 함
- 관련된 여러 파일을 동시에 수정하여 일관성을 유지해야 함
- 기존 코드 내에서 정확한 위치에 코드를 삽입 및 수정해야 함
- 타이핑 중 실시간 코드 제안 및 자동 완성을 활용해야 함
- 복잡한 코드 블록에 대한 한국어 설명을 자동 생성해야 함
- 오류 발생 시 원인 분석 및 수정 방안을 제시해야 함
- 코드 개선 방안 및 리팩토링 제안을 자동 제공해야 함
- 기존 코드에 대한 단위 테스트를 자동 생성해야 함
- 코드 변경 시 관련 문서를 자동 업데이트해야 함
- 코드 간 의존성 분석 및 영향도를 평가해야 함
- 프로젝트 진행 상황을 자동으로 추적하고 관리해야 함

## 🏗️ 아키텍처 및 디자인 패턴 규칙 (필수 - 모든 코드 생성 시 적용)
- 시스템별로 폴더를 분리하고 네임스페이스와 일치시켜야 함
- 싱글톤 매니저는 Instance 프로퍼티와 Awake에서 초기화해야 함
- 모듈형 시스템 구조를 유지해야 함 (AnimationSystem, CombatSystem 등)
- 상태 기반 게임 로직을 구현해야 함
- 팩토리 패턴은 Factory 접미사로 끝나야 함
- 헬퍼 클래스는 Helper 접미사로 끝나야 함
- 컨트롤러 클래스는 Controller 접미사로 끝나야 함
- 인터페이스 기반 설계로 구현체 교체 가능해야 함
- 의존성 주입 패턴을 활용하여 느슨한 결합을 구현해야 함
- 이벤트 기반 아키텍처로 시스템 간 통신을 구현해야 함
- 전략 패턴을 활용하여 알고리즘을 런타임에 교체 가능하게 해야 함
- 옵저버 패턴을 활용하여 이벤트 기반 시스템을 구현해야 함

## ⚡ Unity 2D 최적화 규칙 (중간 우선순위 - 가능한 한 적용)
- Unity 2D Built-in Render Pipeline에 최적화된 코드를 작성해야 함
- Sprite Atlas를 활용하여 Draw Call을 최소화해야 함
- 2D Physics 2D를 사용하고 3D Physics는 사용하지 않아야 함
- Sprite Renderer의 Sorting Layer와 Order in Layer를 적절히 설정해야 함
- Tilemap을 활용한 레벨 디자인을 지원하는 코드를 작성해야 함
- 2D Animation System을 활용한 애니메이션 코드를 작성해야 함
- 메서드당 20줄 이하로 작성하는 것을 권장함
- 매직 넘버를 제거하고 상수로 정의해야 함
- #region을 사용하여 코드 섹션을 구분해야 함
- 단계별 리팩토링을 수행해야 함 (한 번에 하나의 기능만 수정)

## 💡 Unity 6000.0.42f1 특화 규칙 (낮은 우선순위 - 상황에 따라 적용)
- Unity 6의 새로운 2D 기능을 적극 활용해야 함
- Unity 6의 개선된 Sprite Renderer 기능을 사용해야 함
- Unity 6의 새로운 2D Physics 2D 기능을 활용해야 함
- Unity 6의 개선된 Tilemap 기능을 사용해야 함
- Unity 6의 새로운 2D Animation System을 활용해야 함
- Unity 6의 개선된 Built-in Render Pipeline 기능을 사용해야 함
- Unity 6의 새로운 Input System을 활용해야 함
- Unity 6의 개선된 UI Toolkit을 사용해야 함
- Unity 6의 새로운 Analytics 기능을 활용해야 함
- Unity 6의 개선된 Cloud Build 기능을 사용해야 함

## 🎯 Unity 2D 코딩 표준 (중간 우선순위)
- 클래스는 PascalCase, 변수는 camelCase로 작성해야 함
- 인터페이스는 I 접두사, 매니저는 Manager 접미사를 사용해야 함
- ScriptableObject는 Data 접미사로 끝나도록 해야 함
- 이벤트는 System.Action을 사용하고 On 접두사로 시작해야 함
- 모든 Inspector 필드 라벨과 툴팁은 한국어로 작성해야 함
- #region을 사용하여 코드 섹션을 명확히 구분해야 함
- 상수는 UPPER_CASE로 작성해야 함 (예: MAX_HEALTH)
- 열거형(enum)은 PascalCase로 작성해야 함
- 메서드명은 동사로 시작해야 함 (예: GetPlayerData, SetHealth)
- 프로퍼티명은 명사로 작성해야 함 (예: PlayerName, CurrentHealth)
- 불린 변수는 is, has, can 접두사를 사용해야 함 (예: isAlive, hasWeapon)

## 🚀 Unity 2D 성능 최적화 규칙 (중간 우선순위)
- Update() 메서드에서 불필요한 연산을 최소화해야 함
- Sprite Atlas를 활용하여 Draw Call을 최소화해야 함
- 2D Physics 2D의 FixedUpdate()를 적절히 사용해야 함
- Sprite Renderer의 batching을 최적화해야 함
- Tilemap의 효율적인 사용을 위해 Chunk 기반 로딩을 구현해야 함
- 2D Animation의 효율적인 사용을 위해 Animation Event를 활용해야 함
- Unity Profiler를 활용한 2D 성능 측정을 필수로 해야 함
- 코루틴 대신 async/await 패턴을 우선 사용해야 함
- 불필요한 GameObject.Find() 호출을 최소화해야 함
- UI 업데이트 빈도를 최적화해야 함 (필요시에만 갱신)

## 🏗️ Unity 2D 아키텍처 설계 규칙 (중간 우선순위)
- 시스템별로 폴더를 분리하고 네임스페이스와 일치시켜야 함
- 매니저 클래스에서만 싱글톤 패턴을 사용하고, Instance 프로퍼티와 Awake에서 초기화해야 함
- 상태 기반 로직을 구현하여 유연한 동작을 제어해야 함
- 객체 생성 로직을 캡슐화하고, Factory 접미사로 끝나도록 해야 함
- 유틸리티 기능을 분리하고, Helper 접미사로 끝나도록 해야 함
- 사용자 입력 및 시스템 제어를 위해 Controller 접미사로 끝나도록 해야 함
- 이벤트 기반 시스템으로 느슨한 결합을 구현해야 함
- 알고리즘을 런타임에 교체 가능한 구조로 설계해야 함
- 기능별 모듈화로 재사용성과 확장성을 확보해야 함

## 🔄 Unity 2D 리팩토링 규칙 (중간 우선순위)
- 기존 코드를 리팩토링하는 것을 새 기능 생성보다 우선해야 함
- 구현 전에 유사한 기존 스크립트와 기능을 항상 검색해야 함
- 중복 코드 발견 시 기존 코드 재사용 또는 개선을 제안해야 함
- 불필요한 코드는 완전히 제거하고 주석 처리하지 않아야 함
- 대규모 리팩토링 시 모든 관련 요소를 일관되게 이름을 변경해야 함
- 리팩토링 전 Git 브랜치를 생성한 후 작업해야 함
- 한 번에 하나의 기능만 수정하는 단계별 리팩토링을 해야 함
- 리팩토링 후 기존 기능 동작을 확인하는 테스트를 필수로 해야 함
- 메서드당 20줄 이하로 코드 복잡도를 관리해야 함
- 매직 넘버를 상수로 정의하여 의미를 명확화해야 함

## 🔀 GitHub 협업 최적화 규칙 (중간 우선순위)
- 스크립트를 새로운 위치로 이동할 때는 삭제 후 생성하지 말고 이동해야 함
- Git 히스토리를 보존하여 협업 시 충돌을 방지해야 함
- 파일 이동 시 Git이 자동으로 추적할 수 있도록 해야 함
- 브랜치 병합 시 파일 이동이 더 안전함
- 기존 스크립트를 삭제하고 새로 생성하면 다른 개발자와 충돌 가능
- 파일 이동은 `git mv` 명령어를 사용하거나 IDE의 이동 기능을 활용해야 함
- 스크립트 네임스페이스 변경 시에도 파일 이동을 통해 처리해야 함
- 협업 중인 프로젝트에서는 파일 삭제/생성보다 이동을 우선해야 함

## 🛡️ Unity 2D 안정성 및 품질 관리 (중간 우선순위)
- 모든 public 메서드는 매개변수 null 체크 후 ArgumentNullException을 발생시켜야 함
- 예외 상황에 대한 명확한 처리 로직을 구현해야 함
- 리소스 해제는 using문 또는 try-finally를 사용해야 함
- 게임 상태 전환 시 안전한 초기화/정리를 해야 함
- 기능 구현을 우선으로 고려한 코드를 작성해야 함
- Update() 메서드에서 필요한 기능만 구현해야 함
- 필요시에만 오브젝트 풀링 패턴을 활용해야 함
- 수정 가능한 구조로 설계해야 함

## 🚨 Unity 2D 에러 처리 표준 (중간 우선순위)
- null 매개변수 전달 시 ArgumentNullException을 발생시켜야 함
- 잘못된 상태에서의 메서드 호출 시 InvalidOperationException을 발생시켜야 함
- 심각한 오류 상황은 GameLogger.Error()로 로깅해야 함
- 경고 상황 및 예외적 상황은 GameLogger.Warning()로 로깅해야 함
- 일반적인 정보성 로깅은 GameLogger.Info()를 사용해야 함
- 예외 발생 시 사용자에게 적절한 피드백을 제공해야 함
- 예외 상황 복구 로직을 구현해야 함 (가능한 경우)
- 로그 레벨별 적절한 메시지를 작성해야 함

## 🔍 에러 디버깅 및 개선 규칙 (최우선)
- 에러 발생 시 에러 부분만 보는 것이 아닌 디버그 순서대로 전체 확인
- 1단계: 에러 메시지와 스택 트레이스 분석
- 2단계: 에러 발생 지점의 코드 컨텍스트 분석
- 3단계: 관련된 의존성과 데이터 흐름 추적
- 4단계: 시스템 전체의 상태와 초기화 순서 확인
- 5단계: 유사한 패턴의 다른 코드와 비교 분석
- 6단계: 근본 원인(Root Cause) 식별 및 분석
- 7단계: 예방 가능한 개선점과 패턴 제안
- 8단계: 전체 시스템의 안정성 향상 방안 제시
- 에러 수정 시 단순한 패치가 아닌 근본적 해결책 우선
- 동일한 에러가 재발하지 않도록 시스템적 개선 제안

## 📁 Unity 2D 파일 구조 규칙 (중간 우선순위)
```
Script/
├── CoreSystem/          # 코어 시스템 (CoreScene 전용)
│   ├── Manager/        # 코어 매니저들
│   ├── Interface/      # 코어 인터페이스
│   ├── Audio/          # 오디오 관리
│   ├── Save/           # 저장 관리
│   ├── Animation/      # 애니메이션 관리
│   ├── Utility/        # 코어 유틸리티
│   └── UI/             # 코어 UI
├── AnimationSystem/     # 2D 애니메이션 관리
│   ├── Core/           # 핵심 로직
│   ├── Data/           # 데이터 클래스
│   ├── Interface/      # 인터페이스
│   ├── Manager/        # 매니저 클래스
│   ├── UI/             # UI 관련
│   ├── Helper/         # 헬퍼 클래스
│   ├── Controllers/    # 컨트롤러
│   └── Editor/         # 에디터 전용
├── CharacterSystem/     # 2D 캐릭터 관리
│   ├── Core/           # 핵심 로직
│   ├── Data/           # 데이터 클래스
│   ├── Interface/      # 인터페이스
│   ├── Manager/        # 매니저 클래스
│   ├── UI/             # UI 관련
│   └── Slot/           # 슬롯 시스템
├── CombatSystem/        # 2D 전투 시스템
│   ├── Core/           # 핵심 로직
│   ├── Data/           # 데이터 클래스
│   ├── Interface/      # 인터페이스
│   ├── Manager/        # 매니저 클래스
│   ├── UI/             # UI 관련
│   ├── State/          # 상태 관리
│   ├── Service/        # 서비스 클래스
│   ├── Utility/        # 유틸리티
│   ├── Context/        # 컨텍스트
│   ├── DragDrop/       # 드래그 앤 드롭
│   ├── Event/          # 이벤트 시스템
│   ├── Slot/           # 슬롯 시스템
│   ├── Stage/          # 스테이지 관리
│   ├── Trun/           # 턴 관리
│   └── Intialization/  # 초기화
├── SkillCardSystem/     # 스킬카드 시스템
│   ├── Core/           # 핵심 로직
│   ├── Data/           # 데이터 클래스
│   ├── Interface/      # 인터페이스
│   ├── Manager/        # 매니저 클래스
│   ├── UI/             # UI 관련
│   ├── Factory/        # 팩토리 패턴
│   ├── Effect/         # 효과 시스템
│   ├── Deck/           # 덱 관리
│   ├── Executor/       # 실행기
│   ├── Runtime/        # 런타임 로직
│   ├── Slot/           # 슬롯 시스템
│   └── Validator/      # 검증 시스템
├── InventorySystem/     # 인벤토리 관리
├── UISystem/           # UI 관리
└── UtilitySystem/      # 유틸리티 및 공통 기능
```

## 📂 Unity 2D 스크립트 생성 규칙 (중간 우선순위)
- 스크립트 생성 전에 해당 스크립트의 역할과 목적을 분석해야 함
- 스크립트 이름에 따라 적절한 시스템 폴더를 선택해야 함
- 시스템 내에서 적절한 하위 폴더로 분류해야 함
- 새로운 기능이 필요한 경우 새로운 하위 폴더를 생성해야 함
- 폴더 구조가 프로젝트 룰과 일치하는지 확인해야 함
- 네임스페이스와 폴더 구조가 일치하도록 설정해야 함
- 기존 폴더 구조를 존중하고 일관성을 유지해야 함

## 🏗️ CoreScene 자동화 규칙 (중간 우선순위)
- CoreScene은 모든 씬에서 공유되는 전역 시스템만 포함해야 함
- CoreSystem 폴더의 모든 스크립트는 CoreScene에서만 사용해야 함
- CoreSystemInitializer를 사용하여 모든 시스템을 자동 초기화해야 함
- 모든 CoreSystem 매니저는 ICoreSystemInitializable 인터페이스를 구현해야 함
- CoreSystem 스크립트는 반드시 싱글톤 패턴과 DontDestroyOnLoad를 사용해야 함
- CoreScene의 하이라키 구조는 CoreSystems, CoreUtilities, CoreUI, AudioSources, Canvas로 구성해야 함
- 자동 바인딩 시스템을 통해 AudioSource, UI 요소들을 자동 연결해야 함
- CoreSystem 초기화 순서는 GameLogger → CoroutineRunner → 매니저들 → UI 순서로 진행해야 함
- CoreScene에 새로운 시스템 추가 시 CoreSystemInitializer의 초기화 순서에 추가해야 함
- CoreSystem 스크립트는 씬별 로직이 아닌 전역 기능만 구현해야 함
- CoreScene의 모든 오브젝트는 DontDestroyOnLoad로 설정해야 함
- CoreSystemInitializer는 CoreSystem 폴더의 최상위에 배치해야 함

## 📄 대용량 파일 처리 규칙 (최우선)
- 파일 크기가 2000줄을 초과하면 반드시 부분 읽기 적용
- 첫 번째 읽기: 파일 헤더와 구조 파악 (offset: 0, limit: 100)
- 두 번째 읽기: 핵심 내용 분석 (offset: 101, limit: 500)
- 세 번째 읽기: 세부 정보 추출 (offset: 601, limit: 500)
- 필요한 경우 추가 읽기로 모든 내용 커버
- 각 읽기마다 발견된 정보를 누적하여 전체 맥락 유지
- 읽기 실패 시 자동으로 더 작은 청크로 재시도
- 파일 타입별 최적화된 읽기 전략 적용
- Unity 씬 파일: GameObject 구조 우선 추출
- C# 스크립트: 클래스와 메서드 구조 우선 추출
- 프리팹 파일: 컴포넌트 정보 우선 추출
- 읽기 과정에서 발견된 중요 정보를 즉시 요약하여 보고
- 부분 읽기로 인한 정보 누락 방지를 위한 검증 로직 적용
- 메모리 효율성을 고려한 스트리밍 방식 읽기
- 파일 크기 사전 확인 후 적절한 읽기 방식 선택

## 📚 Unity 2D 문서화 규칙 (낮은 우선순위)
- 모든 public 클래스와 메서드에 XML 문서 주석을 필수로 해야 함
- 복잡한 로직은 한국어 주석으로 설명을 추가해야 함
- 코드 변경 시 관련 문서를 자동 업데이트해야 함
- README.md 파일을 유지보수하고 설치 가이드를 제공해야 함
- API 문서 자동 생성 도구를 활용해야 함 (DocFX, Sandcastle)
- 버전별 변경사항을 기록해야 함 (CHANGELOG.md)
- 코드 예시는 실제 프로젝트에서 사용 가능한 형태로만 작성해야 함

## 🚫 AI 사용 흔적 제거 규칙 (최우선)
- AI를 이용했다는 듯한 주석이나 메시지를 절대 넣지 않음
- "AI가 생성한 코드", "자동 생성", "AI 도움" 등의 표현 금지
- 코드 주석은 자연스럽고 전문적으로 작성
- 마치 인간 개발자가 작성한 것처럼 자연스러운 주석 사용
- AI 도구 사용 흔적을 완전히 제거
- 코드 품질은 AI가 생성했어도 인간이 작성한 것처럼 보이도록 함
- 주석 스타일은 프로젝트 전체와 일관성 있게 유지
- 불필요한 설명이나 과도한 주석 추가 금지
- 개발 과정의 세부사항이나 기술적 세부사항 노출 금지
- 중복 설명이나 반복적인 주석 금지
- 간결하고 목적 중심의 주석 작성