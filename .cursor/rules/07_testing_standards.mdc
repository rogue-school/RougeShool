---
alwaysApply: false
description: "Testing standards reference (DO NOT generate test code automatically)"
---

# RougeShool Testing Standards

## ğŸš¨ CRITICAL: Test Code Generation Policy

```
âŒ FORBIDDEN: AIëŠ” í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤

REASON:
- 1ì¸ ê°œë°œ í”„ë¡œì íŠ¸ (ë¹ ë¥¸ í”„ë¡œí† íƒ€ì´í•‘ ìš°ì„ )
- í…ŒìŠ¤íŠ¸ ì½”ë“œëŠ” í•„ìš” ì‹œ ì‚¬ìš©ìê°€ ì§ì ‘ ìš”ì²­

UNLESS user explicitly says:
- "í…ŒìŠ¤íŠ¸ ì½”ë“œ ë§Œë“¤ì–´ì¤˜"
- "ìœ ë‹› í…ŒìŠ¤íŠ¸ ì‘ì„±í•´ì¤˜"
- "í…ŒìŠ¤íŠ¸ ì¶”ê°€í•´ì¤˜"
- "TDDë¡œ ê°œë°œí•´ì¤˜"

â†’ DO NOT generate any test files
â†’ DO NOT suggest creating tests
â†’ DO NOT mention testing in responses
â†’ DO NOT create *Tests.cs files
```

---

## ğŸ“š Reference Only: Testing Standards (ì°¸ê³ ìš©)

> âš ï¸ ì•„ë˜ ë‚´ìš©ì€ **ì°¸ê³ ìš©**ì…ë‹ˆë‹¤.
> ì‚¬ìš©ìê°€ ëª…ì‹œì ìœ¼ë¡œ ìš”ì²­í•˜ì§€ ì•ŠëŠ” í•œ í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ìƒì„±í•˜ì§€ ë§ˆì„¸ìš”.

## ğŸ“‹ Test Coverage Requirements (ì°¸ê³ ìš©)

### Coverage Targets by System
```
REQUIRED Coverage (Must test):
â”œâ”€â”€ Core Logic (CharacterSystem, CombatSystem): 80%+
â”œâ”€â”€ Managers: 70%+
â”œâ”€â”€ Validators/Utilities: 90%+
â””â”€â”€ UI Controllers: 50%+ (MonoBehaviour dependencies)

OPTIONAL Coverage (Test if critical):
â”œâ”€â”€ Data classes (ScriptableObjects): 30%
â”œâ”€â”€ Simple DTOs/POCOs: 20%
â””â”€â”€ Unity lifecycle methods: 20%
```

## ğŸ§ª Unit Test Structure (ì°¸ê³ ìš©)

### Test File Organization
```
Tests/
â”œâ”€â”€ EditMode/                    # Editor tests (no Play mode)
â”‚   â”œâ”€â”€ CharacterSystem/
â”‚   â”‚   â”œâ”€â”€ CardValidatorTests.cs
â”‚   â”‚   â””â”€â”€ CharacterBaseTests.cs
â”‚   â”œâ”€â”€ CombatSystem/
â”‚   â”‚   â””â”€â”€ TurnManagerTests.cs
â”‚   â””â”€â”€ Utilities/
â”‚       â””â”€â”€ GameLoggerTests.cs
â””â”€â”€ PlayMode/                    # Runtime tests (with Unity)
    â”œâ”€â”€ Integration/
    â”‚   â”œâ”€â”€ CombatFlowTests.cs
    â”‚   â””â”€â”€ CardExecutionTests.cs
    â””â”€â”€ Performance/
        â””â”€â”€ PoolingPerformanceTests.cs
```

### Naming Convention
```csharp
// âœ… PATTERN: MethodName_Scenario_ExpectedBehavior

[Test]
public void CanPlayCard_NullCard_ReturnsFalse()
{
    // Arrange
    var validator = new CardValidator();

    // Act
    bool result = validator.CanPlayCard(null, mockPlayer);

    // Assert
    Assert.IsFalse(result);
}

[Test]
public void TakeDamage_NegativeDamage_ThrowsArgumentException()
{
    // Arrange
    var character = CreateTestCharacter();

    // Act & Assert
    Assert.Throws<ArgumentException>(() => character.TakeDamage(-10));
}
```

## ğŸ”§ Zenject Test Environment (ì°¸ê³ ìš©)

### Setting Up DI Container for Tests

```csharp
using NUnit.Framework;
using Zenject;
using UnityEngine;

public class CardProcessorTests
{
    private DiContainer container;
    private ICardValidator mockValidator;
    private CardProcessor cardProcessor;

    [SetUp]
    public void Setup()
    {
        // Create DI container for tests
        container = new DiContainer();

        // Bind mock dependencies
        mockValidator = new MockCardValidator();
        container.Bind<ICardValidator>().FromInstance(mockValidator).AsSingle();

        // Resolve system under test
        cardProcessor = container.Resolve<CardProcessor>();
    }

    [TearDown]
    public void TearDown()
    {
        container = null;
        cardProcessor = null;
    }

    [Test]
    public void ProcessCard_ValidCard_ReturnsTrue()
    {
        // Arrange
        var card = CreateValidCard();

        // Act
        bool result = cardProcessor.ProcessCard(card);

        // Assert
        Assert.IsTrue(result);
    }
}
```

### Mocking Zenject Dependencies

```csharp
// âœ… CORRECT: Use interfaces for mocking

// Production code
public class CombatManager
{
    private readonly ITurnManager turnManager;
    private readonly ICardValidator validator;

    [Inject]
    public CombatManager(ITurnManager turnManager, ICardValidator validator)
    {
        this.turnManager = turnManager;
        this.validator = validator;
    }
}

// Test code
public class CombatManagerTests
{
    private DiContainer container;
    private MockTurnManager mockTurnManager;
    private MockCardValidator mockValidator;

    [SetUp]
    public void Setup()
    {
        container = new DiContainer();

        // Bind mocks
        mockTurnManager = new MockTurnManager();
        mockValidator = new MockCardValidator();

        container.Bind<ITurnManager>().FromInstance(mockTurnManager).AsSingle();
        container.Bind<ICardValidator>().FromInstance(mockValidator).AsSingle();
    }

    [Test]
    public void StartCombat_ValidState_InitializesTurnManager()
    {
        // Arrange
        var combatManager = container.Resolve<CombatManager>();

        // Act
        combatManager.StartCombat();

        // Assert
        Assert.IsTrue(mockTurnManager.WasInitialized);
    }
}

// Simple mock implementation
public class MockTurnManager : ITurnManager
{
    public bool WasInitialized { get; private set; }

    public void Initialize()
    {
        WasInitialized = true;
    }

    // Implement other ITurnManager methods as needed
}
```

## ğŸ¯ Test Categories (ì°¸ê³ ìš©)

### Category Attributes
```csharp
using NUnit.Framework;

// Fast tests (< 1ms)
[Test]
[Category("Fast")]
public void Validator_SimpleCheck_ReturnsQuickly()
{
    // Test code
}

// Integration tests (slower)
[Test]
[Category("Integration")]
public void CombatFlow_FullRound_CompletesSuccessfully()
{
    // Test code
}

// Performance tests
[Test]
[Category("Performance")]
public void ObjectPool_1000Allocations_UnderThreshold()
{
    // Test code
}
```

## ğŸ“š Additional Resources (ì°¸ê³ ìš©)

```
âœ… RECOMMENDED Reading:
â”œâ”€â”€ Unity Test Framework Documentation
â”œâ”€â”€ Zenject Testing Guide
â”œâ”€â”€ NUnit Best Practices
â””â”€â”€ Test-Driven Development (TDD) for Unity
```
