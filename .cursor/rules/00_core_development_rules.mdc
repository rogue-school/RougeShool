---
alwaysApply: true
description: "Core development principles: SOLID, architecture patterns, performance optimization"
---

# RougeShool Core Development Rules

## ğŸ† SOLID Principles

### Single Responsibility Principle (SRP)
```csharp
// âœ… Good: Single responsibility
public class CardValidator
{
    public bool CanPlayCard(SkillCard card, IPlayer player)
    {
        return card != null && card.IsAvailable && player.CurrentMana >= card.ManaCost;
    }
}
```

### Open-Closed Principle (OCP)
```csharp
// âœ… Good: Open for extension, closed for modification
public abstract class CardEffect
{
    public abstract void Apply(IPlayer player);
}

public class DamageEffect : CardEffect
{
    public override void Apply(IPlayer player) { /* damage logic */ }
}
```

### Dependency Inversion Principle (DIP)
```csharp
// âœ… Good: Depend on abstractions
public class CardProcessor
{
    private readonly ICardValidator validator;

    [Inject]
    public CardProcessor(ICardValidator validator)
    {
        this.validator = validator ?? throw new ArgumentNullException(nameof(validator));
    }
}
```

## ğŸ”¥ Critical Rules

### 1. Code Reuse Priority
```
ğŸš¨ NEVER generate new code without reviewing existing code
âœ… ALWAYS: codebase_search â†’ grep â†’ read_file â†’ evaluate reuse
```

### 2. Exception Handling Strategy

#### Exception Handling Levels (3-Tier Strategy)

```csharp
// âœ… LEVEL 1: Validation Layer (throw only)
// - Input validation at method entry
// - Contract enforcement
// - NO logging (caller handles it)

public void ProcessCard(ISkillCard card)
{
    if (card == null)
        throw new ArgumentNullException(nameof(card), "ì¹´ë“œê°€ nullì…ë‹ˆë‹¤");

    if (!card.IsValid())
        throw new InvalidOperationException("ì¹´ë“œ ìƒíƒœê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤");
}

// âœ… LEVEL 2: Operation Layer (log + wrap)
// - Business logic execution
// - Log error context
// - Wrap exception with additional context

public bool ExecuteCard(ISkillCard card)
{
    try
    {
        ProcessCard(card); // May throw from Level 1
        return card.Execute();
    }
    catch (ArgumentNullException ex)
    {
        GameLogger.LogError($"ì¹´ë“œ ì‹¤í–‰ ì‹¤íŒ¨ (null): {ex.Message}", GameLogger.LogCategory.Error);
        throw; // Re-throw for caller to handle
    }
    catch (Exception ex)
    {
        GameLogger.LogError($"ì¹´ë“œ ì‹¤í–‰ ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜: {ex.Message}", GameLogger.LogCategory.Error);
        throw new InvalidOperationException("ì¹´ë“œ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ", ex);
    }
}

// âœ… LEVEL 3: Boundary Layer (log + handle gracefully)
// - UI/Event handlers
// - User-facing operations
// - Catch and recover gracefully
// - DON'T re-throw (prevent app crash)

public void OnCardClicked(ISkillCard card)
{
    try
    {
        ExecuteCard(card);
    }
    catch (Exception ex)
    {
        GameLogger.LogError($"UI ì¹´ë“œ í´ë¦­ ì²˜ë¦¬ ì˜¤ë¥˜: {ex.Message}", GameLogger.LogCategory.UI);
        ShowErrorMessage("ì¹´ë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
        // DON'T re-throw at UI boundary
    }
}
```

#### Null-Safety Patterns

```csharp
// âœ… PREFERRED: Early return for optional dependencies
public void PlaySound(AudioClip clip)
{
    if (clip == null)
    {
        GameLogger.LogWarning("AudioClipì´ nullì…ë‹ˆë‹¤", GameLogger.LogCategory.Audio);
        return; // Graceful degradation
    }

    audioSource.PlayOneShot(clip);
}

// âœ… REQUIRED: Throw for required dependencies
public void Initialize(ICardManager cardManager)
{
    if (cardManager == null)
        throw new ArgumentNullException(nameof(cardManager), "CardManagerëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤");

    this.cardManager = cardManager;
}

// âœ… REQUIRED: Zenject DI validation
[Inject]
public void Construct(IAudioManager audioManager, ICardValidator validator)
{
    this.audioManager = audioManager ?? throw new ArgumentNullException(nameof(audioManager));
    this.validator = validator ?? throw new ArgumentNullException(nameof(validator));
}
```

### 3. Korean Localization
```csharp
// âœ… All Inspector fields in Korean
[Header("ì „íˆ¬ ì„¤ì •")]
[SerializeField] private int maxHealth = 100;

[Tooltip("í”Œë ˆì´ì–´ì˜ ìµœëŒ€ ì²´ë ¥ì…ë‹ˆë‹¤")]
[SerializeField] private int playerMaxHealth = 100;
```

## ğŸ“‹ Architecture Patterns

### Zenject DI (NO Singleton)
```csharp
// âœ… Use Zenject DI
public class CoreSystemInstaller : MonoInstaller<CoreSystemInstaller>
{
    [SerializeField] private AudioManager audioManager;

    public override void InstallBindings()
    {
        Container.Bind<IAudioManager>().FromInstance(audioManager).AsSingle();
    }
}

// âŒ DON'T use Singleton
// public static MyManager Instance { get; private set; } // FORBIDDEN
```

### DOTween Pro (ê¶Œì¥ + ë©”ëª¨ë¦¬ ì•ˆì „ í•„ìˆ˜)

#### Basic DOTween Usage
```csharp
// âœ… ê¶Œì¥: UI/ì˜¤ë¸Œì íŠ¸ ì• ë‹ˆë©”ì´ì…˜ì— DOTween Pro ì‚¬ìš©
transform.DOMove(targetPosition, duration)
    .SetEase(Ease.OutQuad)
    .OnComplete(() => GameLogger.LogInfo("ì´ë™ ì™„ë£Œ", GameLogger.LogCategory.UI));

// âš ï¸ í—ˆìš©: ìºë¦­í„° ì• ë‹ˆë©”ì´ì…˜ì€ Unity Animator ì‚¬ìš© ê°€ëŠ¥
```

#### DOTween Memory Safety (CRITICAL)

```csharp
// âœ… REQUIRED: Track and cleanup tweens
public class SafeAnimationController : MonoBehaviour
{
    private List<Tween> activeTweens = new List<Tween>();

    public void PlayCardAnimation(Transform cardTransform)
    {
        var tween = cardTransform.DOScale(1.2f, 0.3f)
            .SetEase(Ease.OutBack)
            .SetAutoKill(true)  // âœ… CRITICAL: Auto-cleanup when complete
            .OnComplete(() => {
                activeTweens.Remove(tween);
                GameLogger.LogInfo("ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ", GameLogger.LogCategory.UI);
            });

        activeTweens.Add(tween);
    }

    private void OnDisable()
    {
        // âœ… CRITICAL: Kill all tweens when component disabled
        foreach (var tween in activeTweens)
        {
            if (tween != null && tween.IsActive())
                tween.Kill();
        }
        activeTweens.Clear();
    }

    private void OnDestroy()
    {
        // âœ… CRITICAL: Kill all tweens when object destroyed
        foreach (var tween in activeTweens)
        {
            if (tween != null && tween.IsActive())
                tween.Kill();
        }
        activeTweens.Clear();
    }
}
```

#### DOTween Sequence Pattern

```csharp
// âœ… CORRECT: Sequence with proper cleanup
public class CardAnimationManager : MonoBehaviour
{
    private Sequence currentSequence;

    public void PlayCardSequence(Transform card)
    {
        // Kill previous sequence if exists
        currentSequence?.Kill();

        currentSequence = DOTween.Sequence()
            .Append(card.DOScale(1.2f, 0.2f))
            .Append(card.DOMove(targetPos, 0.3f))
            .SetAutoKill(true)  // âœ… Auto-cleanup
            .OnComplete(() => {
                currentSequence = null;
                GameLogger.LogInfo("ì‹œí€€ìŠ¤ ì™„ë£Œ", GameLogger.LogCategory.UI);
            });
    }

    private void OnDisable()
    {
        currentSequence?.Kill();
        currentSequence = null;
    }
}
```

#### DOTween Anti-Patterns

```csharp
// âŒ FORBIDDEN: No cleanup
public void BadAnimation()
{
    transform.DOMove(targetPos, 1f);
    // Missing: SetAutoKill, OnDisable cleanup
    // Result: Memory leak on scene change
}

// âŒ FORBIDDEN: Lambda captures causing GC pressure
public void BadLambda()
{
    for (int i = 0; i < 100; i++)
    {
        // âŒ Creates 100 lambda closures
        transform.DOMove(positions[i], 1f)
            .OnComplete(() => Debug.Log($"Animation {i} complete"));
    }
}

// âœ… CORRECT: Reusable callback
private TweenCallback cachedCallback;

public void GoodLambda()
{
    cachedCallback ??= () => GameLogger.LogInfo("ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ", GameLogger.LogCategory.UI);

    transform.DOMove(targetPos, 1f)
        .OnComplete(cachedCallback);  // âœ… No GC allocation
}
```

#### DOTween Best Practices Checklist

```
âœ… REQUIRED for all DOTween usage:
â”œâ”€â”€ [ ] SetAutoKill(true) called on all tweens
â”œâ”€â”€ [ ] OnDisable() kills all active tweens
â”œâ”€â”€ [ ] OnDestroy() kills all active tweens
â”œâ”€â”€ [ ] Sequences properly cleaned up
â”œâ”€â”€ [ ] Lambda captures minimized (cache callbacks)
â””â”€â”€ [ ] Tween references tracked in collections

âš ï¸ WARNING: Scene transitions without cleanup
â†’ Tweens continue running in destroyed objects
â†’ Causes memory leaks and null reference exceptions
```

## âš¡ Performance Standards

### Object Pooling
```csharp
public class CardPool : MonoBehaviour
{
    private Queue<SkillCard> availableCards = new Queue<SkillCard>();

    public SkillCard GetCard()
    {
        if (availableCards.Count > 0)
            return availableCards.Dequeue();

        return Instantiate(cardPrefab, transform);
    }
}
```

### Unity Optimization
- **Sprite Atlas**: Bundle all sprites
- **2D Physics**: NO 3D Physics
- **Draw Calls**: Minimize via batching
- **Update()**: ê°€ëŠ¥í•œ ì´ë²¤íŠ¸ ê¸°ë°˜ ì‚¬ìš©, ì•„ë˜ ê²½ìš°ë§Œ í—ˆìš©
  - âœ… Physics ê³„ì‚° (FixedUpdate)
  - âœ… Input í´ë§ (GetKey, GetAxis ë“±)
  - âœ… ì‹¤ì‹œê°„ ë³´ê°„ (Lerp, Slerp)
  - âŒ íƒ€ì´ë¨¸ (ì½”ë£¨í‹´/DOTween ì‚¬ìš©)
  - âŒ ì£¼ê¸°ì  ì²´í¬ (ì´ë²¤íŠ¸ ì‚¬ìš©)

## ğŸš« Strict Prohibitions

### âŒ Architecture Violations
- SOLID principle violations
- Circular dependencies
- Singleton pattern (use Zenject)

### âŒ Performance Violations
- FindObjectOfType ì‚¬ìš© (Zenject DI ì‚¬ìš© í•„ìˆ˜)
- Heavy calculations every frame
- Unlimited object instantiation
- GC Alloc ìµœì†Œí™” (Profilerë¡œ ì£¼ê¸°ì  ì¸¡ì •)

### âŒ Code Quality Violations
- Example code generation (unless explicitly requested)
- Duplicate functionality
- Dummy data generation
- AnimationSystem references

## âœ… Required Checklist

- [ ] SOLID principles applied
- [ ] Existing code reused
- [ ] Zenject DI pattern used
- [ ] Performance optimized (pooling, caching)
- [ ] Exception handling complete
- [ ] Korean localization applied
- [ ] Inspector fields in Korean (Header, Tooltip)
- [ ] XML documentation in Korean
- [ ] Compilation: 0 warnings, 0 errors
