---
alwaysApply: true
description: "Core development principles: SOLID, architecture patterns, performance optimization"
---

# RougeShool Core Development Rules

## ğŸ† SOLID Principles

### Single Responsibility Principle (SRP)
```csharp
// âœ… Good: Single responsibility
public class CardValidator
{
    public bool CanPlayCard(SkillCard card, IPlayer player)
    {
        return card != null && card.IsAvailable && player.CurrentMana >= card.ManaCost;
    }
}
```

### Open-Closed Principle (OCP)
```csharp
// âœ… Good: Open for extension, closed for modification
public abstract class CardEffect
{
    public abstract void Apply(IPlayer player);
}

public class DamageEffect : CardEffect
{
    public override void Apply(IPlayer player) { /* damage logic */ }
}
```

### Dependency Inversion Principle (DIP)
```csharp
// âœ… Good: Depend on abstractions
public class CardProcessor
{
    private readonly ICardValidator validator;

    [Inject]
    public CardProcessor(ICardValidator validator)
    {
        this.validator = validator ?? throw new ArgumentNullException(nameof(validator));
    }
}
```

## ğŸ”¥ Critical Rules

### 1. Code Reuse Priority
```
ğŸš¨ NEVER generate new code without reviewing existing code
âœ… ALWAYS: codebase_search â†’ grep â†’ read_file â†’ evaluate reuse
```

### 2. Exception Handling
```csharp
public bool ProcessCard(SkillCard card, IPlayer player)
{
    if (card == null)
    {
        GameLogger.LogError("ì¹´ë“œê°€ nullì…ë‹ˆë‹¤", GameLogger.LogCategory.Error);
        throw new ArgumentNullException(nameof(card));
    }

    try
    {
        return ExecuteCardLogic(card, player);
    }
    catch (Exception ex)
    {
        GameLogger.LogError($"ì¹´ë“œ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {ex.Message}", GameLogger.LogCategory.Error);
        throw;
    }
}
```

### 3. Korean Localization
```csharp
// âœ… All Inspector fields in Korean
[Header("ì „íˆ¬ ì„¤ì •")]
[SerializeField] private int maxHealth = 100;

[Tooltip("í”Œë ˆì´ì–´ì˜ ìµœëŒ€ ì²´ë ¥ì…ë‹ˆë‹¤")]
[SerializeField] private int playerMaxHealth = 100;
```

## ğŸ“‹ Architecture Patterns

### Zenject DI (NO Singleton)
```csharp
// âœ… Use Zenject DI
public class CoreSystemInstaller : MonoInstaller<CoreSystemInstaller>
{
    [SerializeField] private AudioManager audioManager;

    public override void InstallBindings()
    {
        Container.Bind<IAudioManager>().FromInstance(audioManager).AsSingle();
    }
}

// âŒ DON'T use Singleton
// public static MyManager Instance { get; private set; } // FORBIDDEN
```

### DOTween Pro
```csharp
transform.DOMove(targetPosition, duration)
    .SetEase(Ease.OutQuad)
    .OnComplete(() => GameLogger.LogInfo("ì´ë™ ì™„ë£Œ", GameLogger.LogCategory.UI));
```

## âš¡ Performance Standards

### Object Pooling
```csharp
public class CardPool : MonoBehaviour
{
    private Queue<SkillCard> availableCards = new Queue<SkillCard>();

    public SkillCard GetCard()
    {
        if (availableCards.Count > 0)
            return availableCards.Dequeue();

        return Instantiate(cardPrefab, transform);
    }
}
```

### Unity Optimization
- **Sprite Atlas**: Bundle all sprites
- **2D Physics**: NO 3D Physics
- **Draw Calls**: Minimize via batching
- **Update()**: FORBIDDEN - use event-based

## ğŸš« Strict Prohibitions

### âŒ Architecture Violations
- SOLID principle violations
- Circular dependencies
- Singleton pattern (use Zenject)

### âŒ Performance Violations
- FindObjectOfType every frame
- Heavy calculations every frame
- Unlimited object instantiation

### âŒ Code Quality Violations
- Example code generation (unless explicitly requested)
- Duplicate functionality
- Dummy data generation
- AnimationSystem references

## âœ… Required Checklist

- [ ] SOLID principles applied
- [ ] Existing code reused
- [ ] Zenject DI pattern used
- [ ] Performance optimized (pooling, caching)
- [ ] Exception handling complete
- [ ] Korean localization applied
- [ ] Inspector fields in Korean (Header, Tooltip)
- [ ] XML documentation in Korean
- [ ] Compilation: 0 warnings, 0 errors
