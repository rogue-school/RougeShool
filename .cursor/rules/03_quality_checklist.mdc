---
alwaysApply: false
description: "Quality gates and performance standards: SOLID verification, optimization criteria, checklist"
---

# RougeShool Quality Checklist

## üìã Code Generation Checklist

### 1. SOLID Principles
- [ ] **Single Responsibility (SRP)**: One class, one reason to change
- [ ] **Open-Closed (OCP)**: Open for extension, closed for modification
- [ ] **Liskov Substitution (LSP)**: Subtypes can replace parent types
- [ ] **Interface Segregation (ISP)**: No unused interface dependencies
- [ ] **Dependency Inversion (DIP)**: Depend on abstractions, not concrete classes

### 2. Code Quality
- [ ] **Null safety**: All public methods validate parameters
- [ ] **Complexity limits**: Cyclomatic complexity ‚â§ 5, Cognitive complexity ‚â§ 7
- [ ] **Testability**: All external dependencies managed via DI
- [ ] **Korean standard**: All user messages, logs, docs in Korean
- [ ] **Inspector localization**: Header, Tooltip, field names in Korean
- [ ] **XML documentation**: Complete documentation for public APIs

### 3. Unity Performance
- [ ] **Memory management**: < 1KB allocation per frame, minimize GC pressure
- [ ] **Rendering**: < 100 draw calls, batching applied
- [ ] **Script optimization**: NO Update(), event-based required
- [ ] **Object pooling**: Applied to frequently created/destroyed objects
- [ ] **Caching strategy**: Repeated calculations cached (max 5s TTL)

### 4. Project-Specific
- [ ] **Zenject DI**: Proper bindings and scopes, no circular dependencies
- [ ] **DOTween Pro**: Cleanup code on animation complete
- [ ] **CoreSystem**: ICoreSystemInitializable implemented
- [ ] **Code reuse priority**: Existing code improved over new features
- [ ] **Event lifecycle**: Subscribe/unsubscribe in OnEnable/OnDisable

## üéØ Quality Metrics

### Architecture Standards
```csharp
// ‚úÖ SOLID compliant
public interface ICardValidator
{
    bool CanPlayCard(SkillCard card, IPlayer player);
}

public class CardProcessor
{
    private readonly ICardValidator validator;

    [Inject]
    public CardProcessor(ICardValidator validator)
    {
        this.validator = validator ?? throw new ArgumentNullException(nameof(validator));
    }
}
```

### Performance Standards
```csharp
// ‚úÖ Memory-efficient object pooling
public class CardPool : MonoBehaviour
{
    private Queue<SkillCard> availableCards = new Queue<SkillCard>();

    public SkillCard GetCard()
    {
        if (availableCards.Count > 0)
            return availableCards.Dequeue();
        return Instantiate(cardPrefab, transform);
    }

    public void ReturnCard(SkillCard card)
    {
        card.gameObject.SetActive(false);
        availableCards.Enqueue(card);
    }
}
```

## üö´ Auto-Reject Criteria

### ‚ùå Runtime Error Risks
- Null reference exceptions possible
- Array/List index out of bounds
- Type casting failures possible
- Infinite loop possibilities

### ‚ùå Memory Leak Risks
- Event subscription not unsubscribed
- DOTween animation not cleaned up
- Object pooling not used
- Cache size unlimited

### ‚ùå Performance Degradation
- FindObjectOfType every frame
- Heavy calculations every frame
- Unnecessary object instantiation
- Memory allocation not optimized

### ‚ùå Architecture Violations
- SOLID principles violated
- Dependency inversion violated
- Single responsibility violated
- Duplicate functionality created

## üéØ Quality Targets

### Quantitative Targets
- **Code coverage**: Minimum 90%
- **Cyclomatic complexity**: Maximum 5 per method
- **Memory usage**: Maximum 200MB per scene
- **Frame rate**: Minimum 60fps maintained
- **Loading time**: Scene transition < 2s
- **GC pressure**: < 1KB allocation per frame

### Qualitative Targets
- **Architecture consistency**: 100% SOLID compliance
- **Testability**: All external dependencies via DI
- **Extensibility**: Minimal existing code changes for new features
- **Maintainability**: Understandable by others within 5 minutes
- **Documentation completeness**: API usage clear from code alone

### AI Collaboration Quality
- **Requirement understanding**: 95%+ accuracy in interpreting user intent
- **Code reuse rate**: 80%+ utilization of existing code
- **Consistency**: 100% alignment with project patterns
- **Feedback response**: Complete reflection within 1 iteration

## ‚úÖ Final Verification Checklist

### Before Code Submission
- [ ] All public methods have null checks
- [ ] All exception scenarios handled
- [ ] Appropriate logging via GameLogger
- [ ] Korean messages and documentation complete
- [ ] Unity Inspector localized (Header, Tooltip, field names)
- [ ] XML documentation complete
- [ ] Performance optimization applied
- [ ] Memory leak prevention implemented
- [ ] Consistency with existing code verified
- [ ] SOLID principles compliance verified
- [ ] Testable structure designed

### Auto-Reject Conditions
- Runtime error risks present
- Memory leak possibilities present
- Severe performance issues present
- Architecture principles violated
- Duplicate functionality of existing code

## üîß Validation Tools

### Automated Validation
```csharp
// Quality validation extension methods
public static class QualityValidationExtensions
{
    public static bool ValidateNullSafety(this object obj, string objectName)
    {
        if (obj == null)
        {
            GameLogger.LogError($"{objectName}Ïù¥ nullÏûÖÎãàÎã§", GameLogger.LogCategory.Error);
            return false;
        }
        return true;
    }

    public static bool ValidateComponent<T>(this GameObject go) where T : Component
    {
        var component = go.GetComponent<T>();
        if (component == null)
        {
            GameLogger.LogError($"{go.name}Ïóê {typeof(T).Name} Ïª¥Ìè¨ÎÑåÌä∏Í∞Ä ÏóÜÏäµÎãàÎã§", GameLogger.LogCategory.Error);
            return false;
        }
        return true;
    }
}
```

### Performance Monitoring
```csharp
public class PerformanceMonitor : MonoBehaviour
{
    private Dictionary<string, float> operationTimes = new Dictionary<string, float>();

    public void StartOperation(string operationName)
    {
        operationTimes[operationName] = Time.realtimeSinceStartup;
    }

    public void EndOperation(string operationName)
    {
        if (operationTimes.ContainsKey(operationName))
        {
            float duration = Time.realtimeSinceStartup - operationTimes[operationName];

            if (duration > 0.016f) // 60fps = 16.6ms/frame
            {
                GameLogger.LogWarning($"ÏÑ±Îä• Ïù¥Ïäà: {operationName} ({duration:F3}Ï¥à)", GameLogger.LogCategory.Performance);
            }

            operationTimes.Remove(operationName);
        }
    }
}
```
