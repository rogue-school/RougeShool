---
alwaysApply: true
description: "AI code generation workflow: existing code analysis, reusability evaluation, quality verification"
---

# RougeShool AI Workflow Rules

## ğŸ”„ Required Workflow

### Step 1: Code Analysis (NEVER SKIP)
```
ğŸš¨ FORBIDDEN: Generate new code without reviewing existing code
âœ… REQUIRED: Complete existing code review before generation

Workflow:
1. codebase_search â†’ Find similar functionality
2. grep â†’ Verify exact matches
3. read_file â†’ Analyze existing code in detail
4. Evaluate reuse strategy (MODIFY existing > CREATE new)
5. Only create new code if absolutely necessary
```

### Step 1.5: Reuse Decision Matrix (MANDATORY)
```
ğŸ¯ AI MUST respond with this checklist BEFORE generating any code:

EXISTING CODE ANALYSIS:
â”œâ”€â”€ [ ] Found similar functionality? (YES/NO)
â”‚   â”œâ”€â”€ YES â†’ File path: _______
â”‚   â””â”€â”€ NO â†’ Searched patterns: _______
â”œâ”€â”€ [ ] Unused/Dead code detected in target file? (YES/NO)
â”‚   â”œâ”€â”€ YES â†’ List unused methods/fields: _______
â”‚   â””â”€â”€ NO â†’ File is clean
â”œâ”€â”€ [ ] Can existing code be modified? (MODIFY/EXTEND/NEW)
â”‚   â”œâ”€â”€ MODIFY â†’ Use Edit tool on existing file
â”‚   â”œâ”€â”€ EXTEND â†’ Inherit/compose existing class
â”‚   â””â”€â”€ NEW â†’ Justify why existing code cannot be reused
â””â”€â”€ [ ] Modification impact analysis completed?
    â”œâ”€â”€ Files affected: _______
    â”œâ”€â”€ Breaking changes: (YES/NO)
    â””â”€â”€ Risk level: (LOW/MEDIUM/HIGH)

DECISION:
Action: [MODIFY existing file | EXTEND existing class | CREATE new file]
Justification: _______________________
Cleanup Plan: [Remove unused code before adding new] OR [Keep all code]

âš ï¸ IF "CREATE new file" is selected:
   MUST explain why existing code cannot be MODIFIED or EXTENDED

âš ï¸ IF unused/dead code is detected:
   MUST propose cleanup plan BEFORE adding new code
   Example: "Remove unused method X, Y before adding new feature Z"
```

### Anti-Pattern Examples: Creating New Code Instead of Modifying

#### âŒ FORBIDDEN PATTERN #1: Creating New System
```
User: "ì  ìºë¦­í„°ì— ë… ë°ë¯¸ì§€ ì¶”ê°€í•´ì¤˜"

âŒ WRONG AI Response:
"ìƒˆë¡œìš´ PoisonDamageSystem.csë¥¼ ë§Œë“¤ê² ìŠµë‹ˆë‹¤"
â†’ ê¸°ì¡´ EnemyCharacter.csë¥¼ í™•ì¸í•˜ì§€ ì•ŠìŒ
â†’ ì¤‘ë³µ ê¸°ëŠ¥ ìƒì„±
â†’ ì‹œìŠ¤í…œ ë³µì¡ë„ ì¦ê°€
```

#### âœ… CORRECT PATTERN #1: Modifying Existing File
```
User: "ì  ìºë¦­í„°ì— ë… ë°ë¯¸ì§€ ì¶”ê°€í•´ì¤˜"

âœ… CORRECT AI Response:
"EXISTING CODE ANALYSIS:
â”œâ”€â”€ [x] Found: CharacterSystem/Core/EnemyCharacter.cs
â”œâ”€â”€ [x] Can MODIFY: TakeDamage() ë©”ì„œë“œ í™•ì¥ ê°€ëŠ¥
â””â”€â”€ [x] Impact: LOW (ë‹¨ì¼ í´ë˜ìŠ¤ ë‚´ ë©”ì„œë“œ ì¶”ê°€)

DECISION: MODIFY existing file
Action: EnemyCharacter.csì— ApplyPoisonDamage() ë©”ì„œë“œ ì¶”ê°€
Files to modify:
- Assets/Script/CharacterSystem/Core/EnemyCharacter.cs (ë©”ì„œë“œ ì¶”ê°€)
- Assets/Script/CharacterSystem/Interface/ICharacter.cs (ì¸í„°í˜ì´ìŠ¤ í™•ì¥)"
```

#### âŒ FORBIDDEN PATTERN #2: Creating New Manager
```
User: "ì•„ì´í…œ ì°©ìš© ê¸°ëŠ¥ ì¶”ê°€í•´ì¤˜"

âŒ WRONG AI Response:
"ìƒˆë¡œìš´ EquipmentManager.csë¥¼ ë§Œë“¤ê² ìŠµë‹ˆë‹¤"
â†’ ê¸°ì¡´ ItemManagerê°€ ìˆëŠ”ì§€ í™•ì¸ ì•ˆí•¨
â†’ ì¤‘ë³µ ë§¤ë‹ˆì € ìƒì„±
```

#### âœ… CORRECT PATTERN #2: Extending Existing Manager
```
User: "ì•„ì´í…œ ì°©ìš© ê¸°ëŠ¥ ì¶”ê°€í•´ì¤˜"

âœ… CORRECT AI Response:
"EXISTING CODE ANALYSIS:
â”œâ”€â”€ [x] Found: ItemSystem/Manager/ItemManager.cs
â”œâ”€â”€ [x] Can MODIFY: EquipItem() ë©”ì„œë“œ ì¶”ê°€ ê°€ëŠ¥
â””â”€â”€ [x] Impact: MEDIUM (ItemManager + UI ì—°ë™ í•„ìš”)

DECISION: MODIFY existing file
Action: ItemManager.csì— ì°©ìš© ë¡œì§ ì¶”ê°€
Files to modify:
- Assets/Script/ItemSystem/Manager/ItemManager.cs (EquipItem ë©”ì„œë“œ ì¶”ê°€)
- Assets/Script/ItemSystem/Data/ItemData.cs (ì¥ì°© ìŠ¬ë¡¯ ì •ë³´ ì¶”ê°€)"
```

#### âŒ FORBIDDEN PATTERN #3: Creating Duplicate Utility
```
User: "ì¹´ë“œ ìœ íš¨ì„± ê²€ì‚¬ ì¶”ê°€í•´ì¤˜"

âŒ WRONG AI Response:
"ìƒˆë¡œìš´ CardValidationHelper.csë¥¼ ë§Œë“¤ê² ìŠµë‹ˆë‹¤"
â†’ ê¸°ì¡´ CardValidator.cs ë¬´ì‹œ
â†’ ê°™ì€ ê¸°ëŠ¥ì˜ í´ë˜ìŠ¤ ì¤‘ë³µ ìƒì„±
```

#### âœ… CORRECT PATTERN #3: Reusing Existing Utility
```
User: "ì¹´ë“œ ìœ íš¨ì„± ê²€ì‚¬ ì¶”ê°€í•´ì¤˜"

âœ… CORRECT AI Response:
"EXISTING CODE ANALYSIS:
â”œâ”€â”€ [x] Found: CharacterSystem/Utility/CardValidator.cs
â”œâ”€â”€ [x] Can EXTEND: ìƒˆ ê²€ì¦ ë©”ì„œë“œ ì¶”ê°€ ê°€ëŠ¥
â””â”€â”€ [x] Impact: LOW (ê¸°ì¡´ ì¸í„°í˜ì´ìŠ¤ ìœ ì§€)

DECISION: MODIFY existing file
Action: CardValidator.csì— ìƒˆ ê²€ì¦ ë¡œì§ ì¶”ê°€
Files to modify:
- Assets/Script/CharacterSystem/Utility/CardValidator.cs"
```

#### âœ… CORRECT PATTERN #4: Cleanup Unused Code Before Adding New
```
User: "EnemyManagerì— ìƒˆë¡œìš´ ìƒíƒœ ê´€ë¦¬ ê¸°ëŠ¥ ì¶”ê°€í•´ì¤˜"

âœ… CORRECT AI Response:
"EXISTING CODE ANALYSIS:
â”œâ”€â”€ [x] Found: CharacterSystem/Manager/EnemyManager.cs
â”œâ”€â”€ [x] Unused code detected:
â”‚   â”œâ”€â”€ OldStateMethod() - 0 references (grep confirmed)
â”‚   â”œâ”€â”€ tempDebugField - debug field
â”‚   â””â”€â”€ LegacyUpdateState() - commented out
â”œâ”€â”€ [x] Can MODIFY: ê¸°ì¡´ íŒŒì¼ ìˆ˜ì • ê°€ëŠ¥
â””â”€â”€ [x] Impact: MEDIUM (ìƒíƒœ ê´€ë¦¬ ë¡œì§ ì¶”ê°€)

DECISION: MODIFY existing file
Cleanup Plan:
1. Remove OldStateMethod(), LegacyUpdateState()
2. Remove tempDebugField
3. Then add new state management

Files to modify:
- Assets/Script/CharacterSystem/Manager/EnemyManager.cs (cleanup + add)"
```

#### âŒ FORBIDDEN PATTERN #4: Adding New Code Without Cleanup
```
User: "EnemyManagerì— ìƒˆë¡œìš´ ìƒíƒœ ê´€ë¦¬ ê¸°ëŠ¥ ì¶”ê°€í•´ì¤˜"

âŒ WRONG AI Response:
"EXISTING CODE ANALYSIS:
â”œâ”€â”€ [x] Found: CharacterSystem/Manager/EnemyManager.cs
â”œâ”€â”€ [ ] Unused code? (SKIPPED)
â””â”€â”€ [x] Can MODIFY

DECISION: MODIFY existing file
Action: AddNewStateManager() ì¶”ê°€"

â†’ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì½”ë“œ í™•ì¸ ì•ˆí•¨
â†’ ì½”ë“œë² ì´ìŠ¤ ë¹„ëŒ€í™”
â†’ ìœ ì§€ë³´ìˆ˜ì„± ì €í•˜
```

### Step 1.75: Unused Code Detection (MANDATORY WHEN MODIFYING FILES)
```
ğŸ¯ BEFORE modifying any existing file, AI MUST check for unused code:

DETECTION METHOD:
1. grep for method/field references across codebase
2. Count references (0 = unused)
3. Check for commented-out code blocks
4. Identify debug/temp/test code in production

COMMON UNUSED CODE PATTERNS:
â”œâ”€â”€ Methods with 0 grep references
â”œâ”€â”€ Private fields never accessed
â”œâ”€â”€ Commented-out blocks (// or /* */)
â”œâ”€â”€ Debug code (DebugXXX, TempXXX, TestXXX prefixes)
â”œâ”€â”€ "TODO: Remove" comments
â””â”€â”€ Duplicate methods

CLEANUP PRIORITY:
HIGH (Remove immediately before adding new):
â”œâ”€â”€ Commented-out code
â”œâ”€â”€ Debug/Temp/Test code
â”œâ”€â”€ Methods with 0 references
â””â”€â”€ "TODO: Remove" marked code

MEDIUM (Ask user before removing):
â”œâ”€â”€ Public methods with 0 references (might be API)
â”œâ”€â”€ Interface implementations (might be required)
â””â”€â”€ Virtual/Abstract overrides

LOW (Keep):
â”œâ”€â”€ Abstract methods (used by inheritance)
â”œâ”€â”€ Interface definitions (used by DI)
â””â”€â”€ Public API methods (external usage unknown)
```

### Step 2: During Code Generation
```
âœ… Required Implementation:
â”œâ”€â”€ Exception handling (null checks, validation)
â”œâ”€â”€ Korean logging (GameLogger)
â”œâ”€â”€ XML documentation (public APIs)
â”œâ”€â”€ Consistency with existing code
â””â”€â”€ Follow project architecture patterns
```

### Step 3: Post-Generation Verification
```
ğŸ” Quality Verification Checklist:
â”œâ”€â”€ read_lints â†’ 0 warnings, 0 errors
â”œâ”€â”€ Consistency with existing code
â”œâ”€â”€ Exception handling implemented
â”œâ”€â”€ Korean logging implemented
â””â”€â”€ XML documentation complete
```

## ğŸ› ï¸ Tool Usage Rules

### Search Tools (Ordered)
```
1. codebase_search (broad search)
   â”œâ”€â”€ Semantic code search
   â”œâ”€â”€ Find similar functionality
   â””â”€â”€ Identify related systems

2. grep (exact matching)
   â”œâ”€â”€ Exact symbol/string search
   â”œâ”€â”€ Find specific patterns
   â””â”€â”€ Verify exact locations

3. read_file (detailed analysis)
   â”œâ”€â”€ Understand code context
   â”œâ”€â”€ Check implementation details
   â””â”€â”€ Analyze dependencies
```

### Edit Tools Priority
```
PRIORITY 1: Edit (modify existing files)
â”œâ”€â”€ Use Edit tool for existing files
â”œâ”€â”€ Preserve existing structure
â””â”€â”€ Add/modify specific sections

PRIORITY 2: Extend (inherit/compose)
â”œâ”€â”€ Create derived class if needed
â”œâ”€â”€ Implement interface
â””â”€â”€ Use composition pattern

PRIORITY 3: Write (create new files)
â”œâ”€â”€ ONLY if existing code cannot be reused
â”œâ”€â”€ MUST justify why EDIT/EXTEND not possible
â””â”€â”€ Document relationship with existing code
```

### Parallelization
```
Independent operations:
â”œâ”€â”€ 2+ independent search/read tasks
â”œâ”€â”€ Execute in parallel for efficiency
â””â”€â”€ Reduce response time
```

## ğŸ“‹ Quality Verification

### Compilation Verification
```
Required checks:
â”œâ”€â”€ 0 compilation warnings
â”œâ”€â”€ 0 compilation errors
â”œâ”€â”€ 0 linter warnings
â””â”€â”€ 0 runtime errors
```

### Code Quality Verification
```
Required checks:
â”œâ”€â”€ Exception handling complete
â”œâ”€â”€ Korean logging complete
â”œâ”€â”€ XML documentation complete
â”œâ”€â”€ Consistency with existing code
â””â”€â”€ Architecture patterns followed
```

### Performance Verification
```
Recommended checks:
â”œâ”€â”€ Minimize Update() usage
â”œâ”€â”€ Minimize memory allocation
â”œâ”€â”€ Use DOTween Pro
â””â”€â”€ Apply Zenject DI
```

## ğŸš« Strict Prohibitions

### Code Generation Prohibitions
```
NEVER generate:
â”œâ”€â”€ Example code (only when explicitly requested)
â”œâ”€â”€ Dummy data
â”œâ”€â”€ Duplicate functionality
â”œâ”€â”€ AnimationSystem-related code
â”œâ”€â”€ Game-specific reference comments (e.g., "Slay the Spire style")
â”œâ”€â”€ AI-generated code mentions (e.g., "AI generated")
â”œâ”€â”€ Change notification comments (e.g., "ìˆ˜ì •ë¨", "FIXED", "ADDED", "Modified here")
â”œâ”€â”€ Explanatory comments for user (e.g., "ì´ ë¶€ë¶„ì„ ìˆ˜ì •í–ˆìŠµë‹ˆë‹¤", "ì„±ëŠ¥ ê°œì„ ì„ ìœ„í•´ ë³€ê²½")
â”œâ”€â”€ Incomplete explanatory code
â”œâ”€â”€ New files when existing files can be modified
â””â”€â”€ Test code (*Tests.cs files) - UNLESS user explicitly requests
    â”œâ”€â”€ "í…ŒìŠ¤íŠ¸ ì½”ë“œ ë§Œë“¤ì–´ì¤˜"
    â”œâ”€â”€ "ìœ ë‹› í…ŒìŠ¤íŠ¸ ì‘ì„±í•´ì¤˜"
    â”œâ”€â”€ "í…ŒìŠ¤íŠ¸ ì¶”ê°€í•´ì¤˜"
    â””â”€â”€ "TDDë¡œ ê°œë°œí•´ì¤˜"
```

### Workflow Violations
```
NEVER skip:
â”œâ”€â”€ Existing code review step
â”œâ”€â”€ Reusability evaluation step
â”œâ”€â”€ Reuse Decision Matrix (Step 1.5)
â”œâ”€â”€ Quality verification step
â””â”€â”€ Compilation verification step
```

### File Creation Violations
```
ğŸš¨ FORBIDDEN: Creating new files without justification

BEFORE creating ANY new file, AI MUST:
1. Search for existing similar files (codebase_search + grep)
2. Read and analyze existing files (read_file)
3. Evaluate modification possibility
4. Fill Reuse Decision Matrix
5. Justify why EDIT/EXTEND is not possible

IF AI creates new file WITHOUT completing steps 1-5:
â†’ REJECT the response
â†’ Require AI to restart from Step 1
```

## âœ… Success Criteria

### Code Generation Success
```
Success conditions:
â”œâ”€â”€ Existing code reused/extended first
â”œâ”€â”€ 0 compilation warnings/errors
â”œâ”€â”€ Complete exception handling
â”œâ”€â”€ Korean logging implemented
â”œâ”€â”€ XML documentation complete
â””â”€â”€ Consistency with existing code maintained
```

### Workflow Success
```
Success conditions:
â”œâ”€â”€ All required steps completed
â”œâ”€â”€ All required verifications passed
â”œâ”€â”€ All prohibitions followed
â”œâ”€â”€ Reuse Decision Matrix filled
â””â”€â”€ All success criteria met
```

## ğŸ“Š Code Modification Priority

### Decision Tree for Code Changes
```
User Request
    â†“
Step 1: Search existing code
    â”œâ”€â”€ Found? â†’ YES
    â”‚   â†“
    â”‚   Can modify existing file?
    â”‚   â”œâ”€â”€ YES â†’ USE EDIT TOOL âœ… (PRIORITY 1)
    â”‚   â””â”€â”€ NO â†’ Can extend (inherit/compose)?
    â”‚       â”œâ”€â”€ YES â†’ CREATE DERIVED CLASS âœ… (PRIORITY 2)
    â”‚       â””â”€â”€ NO â†’ Justify & CREATE NEW âš ï¸ (PRIORITY 3)
    â””â”€â”€ Found? â†’ NO
        â†“
        Search again with different patterns
        â””â”€â”€ Still not found? â†’ CREATE NEW âœ… (Justified)
```

### Modification Impact Levels
```
LOW Impact (Always safe to modify):
â”œâ”€â”€ Adding new methods to existing class
â”œâ”€â”€ Adding new properties
â”œâ”€â”€ Adding new enum values
â””â”€â”€ Adding new private fields

MEDIUM Impact (Requires careful review):
â”œâ”€â”€ Modifying existing method signatures
â”œâ”€â”€ Changing public properties
â”œâ”€â”€ Modifying interfaces
â””â”€â”€ Changing constructor parameters

HIGH Impact (Requires explicit user approval):
â”œâ”€â”€ Deleting existing methods
â”œâ”€â”€ Changing inheritance hierarchy
â”œâ”€â”€ Breaking API compatibility
â””â”€â”€ Modifying core system architecture
```
