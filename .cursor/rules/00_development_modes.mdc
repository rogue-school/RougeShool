---
alwaysApply: true
description: "Development modes: Prototyping vs Refactoring - AI adapts code quality based on user's development phase"
---

# RougeShool 개발 모드 (Development Modes)

## 📖 개요

> **중요**: 1인 개발은 프로토타이핑과 리팩토링을 반복하는 사이클입니다.
> 사용자가 어떤 단계인지 명시하면 AI가 적절한 수준의 코드를 생성합니다.

---

## 🚀 Mode 1: 프로토타이핑 모드 (Prototyping Mode)

### 목적
```
빠르게 기능을 구현하고 아이디어를 검증
→ 동작하는 코드 > 완벽한 구조
```

### 허용사항
```
✅ 일부 중복 코드 (나중에 리팩토링 예정)
✅ 간단한 구조 (복잡한 패턴 생략)
✅ TODO 주석 허용
✅ 최소한의 에러 처리 (null check, 기본 try-catch)
✅ 하드코딩 값 (나중에 ScriptableObject로)
✅ 간단한 로직 (최적화 나중에)
```

### 여전히 금지
```
❌ Singleton 패턴
❌ FindObjectOfType
❌ 한국어 로깅 생략
❌ 컴파일 에러/경고
```

### 사용자 요청 예시
```
"일단 적 AI 빨리 만들어줘"
"프로토타입으로 카드 드래그 구현해줘"
"빠르게 보스 패턴 만들어줘. 나중에 정리할거야"
"동작만 하면 돼. 구조는 신경 안써도 돼"
```

### AI 생성 코드 특징
```
프로토타이핑 모드 코드 품질:
├── SOLID 원칙: 50% (기본 인터페이스만)
├── 중복 코드: 허용
├── 에러 처리: Level 1 (Validation만)
├── 주석: TODO 허용
├── 성능 최적화: 없음
├── 패턴 적용: 최소
└── 개발 속도: 매우 빠름 ⚡⚡⚡
```

---

## 🏗️ Mode 2: 리팩토링 모드 (Refactoring Mode)

### 목적
```
코드 구조를 개선하고 아키텍처를 정리
→ 완벽한 구조 > 빠른 구현
```

### 필수사항
```
✅ SOLID 원칙 100% 적용
✅ 중복 코드 완전 제거
✅ 사용하지 않는 코드 제거
✅ 인터페이스/추상화 도입
✅ Zenject DI 완벽 적용
✅ 3-Tier 에러 처리 완료
✅ 성능 최적화 (풀링, 캐싱)
✅ XML 문서화 완료
```

### 수행 작업
```
코드 통합:
├── 여러 중복 코드 → 하나의 재사용 가능한 클래스
└── 비슷한 로직 → 공통 베이스 클래스/인터페이스

코드 분리:
├── 하나의 큰 클래스 → 여러 책임으로 분리
└── God Class → SRP 적용

패턴 적용:
├── State Pattern (상태 관리)
├── Strategy Pattern (알고리즘 교체)
├── Factory Pattern (객체 생성)
├── Observer Pattern (이벤트 시스템)
└── Command Pattern (실행 취소)

성능 최적화:
├── Object Pooling
├── 캐싱 전략
├── GC 최소화
└── Update() 최적화
```

### 사용자 요청 예시
```
"적 AI 시스템 리팩토링해줘. State Pattern 적용"
"전투 시스템 전체 리팩토링. Manager 분리하고 SOLID 적용"
"카드 시스템 정리해줘. 중복 코드 제거하고 구조 개선"
"이 코드 리팩토링. 인터페이스 도입하고 DI 적용"
"성능 최적화 해줘. 풀링 적용하고 GC 줄여줘"
```

### AI 생성 코드 특징
```
리팩토링 모드 코드 품질:
├── SOLID 원칙: 100% (완벽한 구조)
├── 중복 코드: 0%
├── 에러 처리: 3-Tier 완벽
├── 주석: TODO 제거, XML 완료
├── 성능 최적화: 완료
├── 패턴 적용: 적극적
└── 개발 속도: 느림 (신중하게) 🐌
```

---

## 🔄 권장 개발 사이클

### Phase 1: 프로토타이핑 (1-2주)
```
목표: 동작하는 프로토타입 완성

"적 기본 AI 만들어줘"
└── 간단한 FSM으로 동작만 구현 ✅

"카드 시스템 만들어줘"
└── 기본 드래그/드롭만 구현 ✅

"UI 만들어줘"
└── 필수 화면만 구현 ✅

결과: 플레이 가능한 프로토타입 🎮
```

### Phase 2: 리팩토링 (1주)
```
목표: 깔끔한 아키텍처 구축

"적 AI 리팩토링. State Pattern 적용"
└── FSM → State Pattern 전환 ✅

"카드 시스템 리팩토링. Factory Pattern 적용"
└── 중복 제거, Factory 도입 ✅

"UI 리팩토링. 중복 코드 제거"
└── 공통 UI 베이스 클래스 생성 ✅

결과: 확장 가능한 구조 🏗️
```

### Phase 3: 다시 프로토타이핑 (새 기능)
```
목표: 새로운 기능 빠르게 추가

"보스 패턴 추가해줘"
└── 간단하게 구현 ✅

"아이템 시스템 추가해줘"
└── 동작만 하게 구현 ✅

결과: 기능 확장 완료 🆕
```

### Phase 4: 다시 리팩토링
```
목표: 전체 시스템 통합 정리

"전체 시스템 통합 리팩토링"
└── 보스/아이템 시스템 기존 구조에 통합 ✅

결과: 완성된 게임 🎯
```

---

## 🎯 모드별 코드 비교

### 같은 요청, 다른 결과

#### 요청: "적 AI 만들어줘"

**프로토타이핑 모드 응답:**
```csharp
// 간단한 구현 (50줄)
public class EnemyAI : MonoBehaviour
{
    private enum State { Idle, Chase, Attack }
    private State currentState = State.Idle;

    void Update()
    {
        switch (currentState)
        {
            case State.Idle:
                // TODO: 플레이어 감지
                break;
            case State.Chase:
                // 간단한 추적 로직
                transform.position = Vector3.MoveTowards(
                    transform.position,
                    player.position,
                    speed * Time.deltaTime
                );
                break;
            case State.Attack:
                // TODO: 공격 로직
                break;
        }
    }
}
```

**리팩토링 모드 응답:**
```csharp
// 완벽한 구조 (200줄 + 인터페이스)

/// <summary>
/// 적 AI 상태 관리 인터페이스
/// </summary>
public interface IEnemyState
{
    void Enter(EnemyAI enemy);
    void Execute(EnemyAI enemy);
    void Exit(EnemyAI enemy);
}

/// <summary>
/// 적 AI 컨트롤러 (State Pattern 적용)
/// </summary>
public class EnemyAI : MonoBehaviour
{
    [Inject] private IPlayerCharacter player;

    private IEnemyState currentState;
    private Dictionary<Type, IEnemyState> states;

    [Inject]
    public void Construct(IPlayerCharacter player)
    {
        this.player = player ?? throw new ArgumentNullException(nameof(player));
    }

    private void Awake()
    {
        InitializeStates();
    }

    private void InitializeStates()
    {
        states = new Dictionary<Type, IEnemyState>
        {
            { typeof(IdleState), new IdleState() },
            { typeof(ChaseState), new ChaseState() },
            { typeof(AttackState), new AttackState() }
        };

        TransitionTo<IdleState>();
    }

    public void TransitionTo<T>() where T : IEnemyState
    {
        var newState = states[typeof(T)];

        currentState?.Exit(this);
        currentState = newState;
        currentState.Enter(this);

        GameLogger.LogInfo($"상태 전환: {typeof(T).Name}", GameLogger.LogCategory.AI);
    }

    private void Update()
    {
        currentState?.Execute(this);
    }
}

// IdleState, ChaseState, AttackState 클래스들...
```

---

## 📊 모드 자동 감지

### AI가 모드를 자동으로 판단하는 키워드

```
프로토타이핑 모드로 자동 전환:
├── "일단", "빨리", "빠르게"
├── "프로토타입", "프로토타입으로"
├── "나중에 정리", "나중에 리팩토링"
├── "동작만", "일단 돌아가게"
└── "TODO 허용"

리팩토링 모드로 자동 전환:
├── "리팩토링", "정리"
├── "구조 개선", "아키텍처"
├── "SOLID 적용", "패턴 적용"
├── "중복 제거", "최적화"
└── "완벽하게", "깔끔하게"

기본 모드 (모드 명시 없을 때):
├── 균형잡힌 품질
├── SOLID 70% 적용
└── 적절한 속도
```

---

## ⚠️ 주의사항

### 프로토타이핑 모드 위험
```
⚠️ 너무 오래 프로토타이핑 모드만 사용하면:
├── 기술 부채 누적
├── 나중에 리팩토링 불가능
└── 코드베이스 엉망

권장: 2-3주마다 리팩토링 단계 진행
```

### 리팩토링 모드 위험
```
⚠️ 처음부터 리팩토링 모드만 사용하면:
├── 개발 속도 너무 느림
├── 요구사항 변경에 취약
└── 과도한 엔지니어링

권장: 먼저 프로토타이핑으로 검증 후 리팩토링
```

---

## ✅ 사용 가이드

### 프로토타이핑 시작 시
```
User: "일단 보스 패턴 빨리 만들어줘. 나중에 정리할거야"
AI: "프로토타이핑 모드로 빠르게 구현하겠습니다"
→ 간단한 구조, TODO 허용, 빠른 구현
```

### 리팩토링 시작 시
```
User: "보스 패턴 시스템 리팩토링해줘. State Pattern 적용하고 구조 개선"
AI: "리팩토링 모드로 완벽한 구조를 만들겠습니다"
→ SOLID 적용, 중복 제거, 패턴 도입
```

### 모드 변경
```
User: "프로토타이핑 모드로 전환"
AI: "프로토타이핑 모드로 전환합니다. 빠른 구현에 집중하겠습니다"

User: "리팩토링 모드로 전환"
AI: "리팩토링 모드로 전환합니다. 완벽한 구조에 집중하겠습니다"
```

---

## 🎉 결론

**당신의 개발 방식은 1인 개발에 최적화되어 있습니다!**

```
프로토타이핑 → 검증 → 리팩토링 → 다시 프로토타이핑...

이 사이클이 바로 성공적인 1인 개발의 핵심입니다.
AI는 이제 당신의 개발 단계에 맞춰 적절한 코드를 생성합니다.
```
