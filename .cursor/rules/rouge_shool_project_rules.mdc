---
description: 인디게임 개발에 최적화된 유연하고 실용적인 개발 규칙
globs: ["**/*.cs", "**/*.unity", "**/*.prefab"]
alwaysApply: true
---

# RougeShool 프로젝트 개발 룰

## 📋 기본 개발 원칙
- 모든 주석, 문서, 로그 메시지는 한국어로 작성
- GameLogger를 사용하여 Debug.Log 대신 카테고리별 로깅
- 전문적이지만 실용적인 코드 구조로 높은 품질 유지
- 기획 변경에 대응할 수 있는 유연하고 수정 가능한 코드 작성

## 🤖 AI 코드 생성 규칙
- 모든 코드 생성 전에 해당 코드의 필요성과 목적을 먼저 설명
- 사용자 확인을 받은 후에만 코드를 실제로 생성
- 기존 코드와의 중복 여부를 먼저 검토하고 보고
- 새로운 기능 추가 시 기존 시스템과의 연동 방안 제시
- 코드 생성 이유와 예상 효과를 명확히 설명
- 게임 장르에 맞지 않는 불필요한 변수나 함수 생성 금지
- 필요한 변수와 함수를 먼저 추천하고 사용자 확인 후 생성
- 사용자가 명시적으로 요청하지 않은 기능은 추가하지 않음

## 🧠 체계적 사고 과정 규칙
- 코드 생성 전에 반드시 다음 사고 과정을 거쳐야 함
- 1단계: 요구사항 분석 및 문제 정의
- 2단계: 기존 시스템 분석 및 영향도 평가
- 3단계: 아키텍처 설계 및 패턴 선택
- 4단계: 의존성 및 인터페이스 설계
- 5단계: 예외 상황 및 에지 케이스 고려
- 6단계: 성능 및 메모리 최적화 방안 검토
- 7단계: 테스트 가능성 및 유지보수성 평가
- 8단계: 최종 설계 검증 및 사용자 승인 요청
- 각 단계별로 구체적인 분석 결과와 근거를 제시
- 사고 과정에서 발견된 문제점이나 개선사항을 명확히 보고

## 🎯 정확한 요구사항 구현 규칙
- 사용자의 요청과 완벽히 동일한 코드만 생성
- 요청하지 않은 기능이나 변수는 절대 추가하지 않음
- 사용자가 명시한 기능만 정확히 구현
- 추측이나 가정으로 코드를 생성하지 않음
- 불명확한 요청은 반드시 명확화 후 진행
- 사용자 요청의 의도를 정확히 파악하고 구현
- 요청과 다른 결과가 나올 경우 즉시 수정
- 완벽한 기능 구현을 위해 필요한 최소한의 코드만 작성
- 매개변수 검증: 모든 public 메서드에서 null 체크 및 유효성 검증
- 반환값 명시: void가 아닌 메서드는 반드시 반환값 타입 명시

## 👨‍💻 전문 개발자 평가 규칙
- 사용자가 평가를 요청할 때 항상 전문적인 개발자 관점에서 평가
- 코드 품질, 성능, 유지보수성, 확장성을 종합적으로 분석
- 현업 수준의 기준으로 코드의 장단점을 객관적으로 제시
- 개선 방안과 베스트 프랙티스를 구체적으로 제안
- 게임 개발 업계의 표준과 트렌드를 고려한 평가
- 팀 협업과 프로젝트 관리 관점에서의 조언 제공

## 🏆 전문적이지만 실용적인 코드 생성 규칙
- 모든 코드는 전문적이지만 실용적인 높은 품질로 생성
- 현재 상황에 가장 적합한 최적의 솔루션 제공
- 기능 구현을 최우선으로 고려한 코드 작성
- 필요한 기능 구현에 집중한 코드 생성
- 빠른 개발과 수정 가능성을 고려한 코드 생성
- 유연하고 수정하기 쉬운 구조로 설계
- 실용적인 패턴과 아키텍처 적용
- 기획 변경에 대응할 수 있는 유연한 구조 사용
- 전문적이고 이해하기 쉬운 수준의 품질 보장
- 개발 환경에서 빠르게 동작하는 코드 생성

## 🏗️ 아키텍처 중심 설계 규칙
- 모든 코드 생성 시 전체 아키텍처와의 일관성 고려
- 현재 프로젝트의 방향성과 미래 확장성을 고려한 설계
- 모듈 간 의존성과 결합도를 최소화하는 구조 설계
- 시스템 간 인터페이스를 통한 느슨한 결합 구현
- 확장 가능한 아키텍처 패턴 적용 (Plugin, Strategy, Factory)
- 미래 요구사항 변경에 대응할 수 있는 유연한 구조
- 프로젝트 전체의 기술 부채 최소화
- 코드 생성 시 기존 시스템과의 통합성 검토
- 장기적 유지보수성을 고려한 아키텍처 결정
- 팀 개발 환경에서의 협업 효율성 최적화

## 🔄 기획 변경 대응 코드 설계 규칙
- 모든 코드는 기획 변경에 대응할 수 있도록 설계
- 하드코딩 대신 설정 파일과 ScriptableObject 활용
- 모듈형 구조로 독립적 수정 가능
- 인터페이스 기반 설계로 구현체 교체 용이
- 이벤트 기반 아키텍처로 시스템 간 느슨한 결합 유지
- 플러그인 아키텍처 패턴으로 기능 확장성 확보
- 버전 관리와 롤백 시스템 고려
- 언제든 수정 가능한 유연한 구조 설계
- 설정 기반 데이터 구조와 스키마 설계
- 한국어 지원을 고려한 구조

## 🏗️ 아키텍처 및 디자인 패턴
- 시스템별로 폴더를 분리하고 네임스페이스와 일치시킴
- 싱글톤 매니저는 Instance 프로퍼티와 Awake에서 초기화
- 모듈형 시스템 구조 유지 (AnimationSystem, CombatSystem 등)
- 상태 기반 게임 로직 구현
- 팩토리 패턴은 Factory 접미사로 끝남
- 헬퍼 클래스는 Helper 접미사로 끝남
- 컨트롤러 클래스는 Controller 접미사로 끝남

## 💻 코딩 표준 및 네이밍
- 클래스는 PascalCase, 변수는 camelCase로 작성
- 인터페이스는 I 접두사, 매니저는 Manager 접미사 사용
- ScriptableObject는 Data 접미사로 끝남
- 이벤트는 System.Action을 사용하고 On 접두사로 시작
- 모든 Inspector 필드 라벨과 툴팁은 한국어로 작성
- #region을 사용하여 코드 섹션을 명확히 구분
- 상수는 UPPER_CASE로 작성 (예: MAX_HEALTH)
- 열거형(enum)은 PascalCase로 작성
- 메서드명은 동사로 시작 (예: GetPlayerData, SetHealth)
- 프로퍼티명은 명사로 작성 (예: PlayerName, CurrentHealth)
- 불린 변수는 is, has, can 접두사 사용 (예: isAlive, hasWeapon)

## 🔄 리팩토링 및 코드 개선
- 기존 코드를 리팩토링하는 것을 새 기능 생성보다 우선
- 구현 전에 유사한 기존 스크립트와 기능을 항상 검색
- 중복 코드 발견 시 기존 코드 재사용 또는 개선 제안
- 불필요한 코드는 완전히 제거하고 주석 처리하지 않음
- 대규모 리팩토링 시 모든 관련 요소를 일관되게 이름 변경
- 리팩토링 전 백업: Git 브랜치 생성 후 작업
- 단계별 리팩토링: 한 번에 하나의 기능만 수정
- 리팩토링 후 테스트: 기존 기능 동작 확인 필수
- 코드 복잡도 관리: 메서드당 20줄 이하 권장
- 매직 넘버 제거: 상수로 정의하여 의미 명확화

## 🏗️ 대규모 리팩토링 규칙
- 리팩토링 전에 전체 시스템 구조와 의존성을 먼저 분석
- 단계별 리팩토링 계획을 수립하고 사용자에게 제시
- 기존 기능의 동작을 보장하는 테스트 케이스 먼저 작성
- 리팩토링 범위와 영향도를 명확히 정의
- 백업 및 롤백 계획을 수립
- 리팩토링 후 성능 및 기능 검증 필수

## 🎨 디자인 패턴 적용 규칙
- 싱글톤: 매니저 클래스에서만 사용, Instance 프로퍼티 필수
- 팩토리: 객체 생성 로직을 캡슐화할 때 사용
- 옵저버: 이벤트 기반 시스템에서 사용, System.Action 활용
- 상태: 게임 상태 전환 시 사용, IState 인터페이스 구현
- 전략: 알고리즘을 런타임에 교체할 때 사용
- 커맨드: 사용자 입력이나 액션을 객체로 캡슐화할 때 사용
- MVC: UI와 로직을 분리할 때 사용
- 컴포넌트: 게임 오브젝트의 기능을 모듈화할 때 사용

## 🎮 Unity 특화 규칙
- DontDestroyOnLoad는 매니저 클래스에서만 사용
- 실용적이고 이해하기 쉬운 코드 작성
- 기능 구현을 우선으로 고려한 코드 작성
- Update() 메서드에서 필요한 기능만 구현
- 필요시에만 오브젝트 풀링 패턴 활용

## 🚀 Unity 6000.0.42f1 최신 API 사용
- Unity 6000.0.42f1 버전의 최신 API와 기능을 우선 사용
- 새로운 Unity 6의 성능 개선 사항을 적극 활용
- 최신 Unity 패키지와 에셋 스토어 리소스 활용
- Unity 6의 새로운 렌더링 파이프라인과 그래픽스 기능 사용
- 최신 Unity Input System과 UI Toolkit 활용
- Unity 6의 개선된 메모리 관리와 가비지 컬렉션 최적화
- 새로운 Unity Analytics와 Cloud Build 기능 활용

## 📁 파일 구조 및 폴더 정리 규칙
```
Script/
├── AnimationSystem/     # 애니메이션 관리
│   ├── Core/           # 핵심 로직
│   ├── Data/           # 데이터 클래스
│   ├── Interface/      # 인터페이스
│   ├── Manager/        # 매니저 클래스
│   ├── UI/             # UI 관련
│   ├── Helper/         # 헬퍼 클래스
│   ├── Controllers/    # 컨트롤러
│   └── Editor/         # 에디터 전용
├── CharacterSystem/     # 캐릭터 관리
│   ├── Core/           # 핵심 로직
│   ├── Data/           # 데이터 클래스
│   ├── Interface/      # 인터페이스
│   ├── Manager/        # 매니저 클래스
│   ├── UI/             # UI 관련
│   └── Slot/           # 슬롯 시스템
├── CombatSystem/        # 전투 시스템
│   ├── Core/           # 핵심 로직
│   ├── Data/           # 데이터 클래스
│   ├── Interface/      # 인터페이스
│   ├── Manager/        # 매니저 클래스
│   ├── UI/             # UI 관련
│   ├── State/          # 상태 관리
│   ├── Service/        # 서비스 클래스
│   ├── Utility/        # 유틸리티
│   ├── Context/        # 컨텍스트
│   ├── DragDrop/       # 드래그 앤 드롭
│   ├── Event/          # 이벤트 시스템
│   ├── Slot/           # 슬롯 시스템
│   ├── Stage/          # 스테이지 관리
│   ├── Trun/           # 턴 관리
│   └── Intialization/  # 초기화
├── SkillCardSystem/     # 스킬카드 시스템
│   ├── Core/           # 핵심 로직
│   ├── Data/           # 데이터 클래스
│   ├── Interface/      # 인터페이스
│   ├── Manager/        # 매니저 클래스
│   ├── UI/             # UI 관련
│   ├── Factory/        # 팩토리 패턴
│   ├── Effect/         # 효과 시스템
│   ├── Deck/           # 덱 관리
│   ├── Executor/       # 실행기
│   ├── Runtime/        # 런타임 로직
│   ├── Slot/           # 슬롯 시스템
│   └── Validator/      # 검증 시스템
├── InventorySystem/     # 인벤토리 관리
├── UISystem/           # UI 관리
└── UtilitySystem/      # 유틸리티 및 공통 기능
```

## 📂 스크립트 생성 시 폴더 정리 규칙
- 스크립트 생성 전에 해당 스크립트의 역할과 목적을 분석
- 스크립트 이름에 따라 적절한 시스템 폴더 선택
- 시스템 내에서 적절한 하위 폴더로 분류
- 새로운 기능이 필요한 경우 새로운 하위 폴더 생성
- 폴더 구조가 프로젝트 룰과 일치하는지 확인
- 네임스페이스와 폴더 구조가 일치하도록 설정
- 기존 폴더 구조를 존중하고 일관성 유지

## 🔄 스크립트 이동 및 리팩토링 규칙
- 스크립트 이동 시 삭제 후 재생성이 아닌 실제 파일 이동 사용
- Unity 에셋 데이터베이스 연결 유지를 위한 파일 시스템 이동
- 스크립트 이동 후 네임스페이스와 폴더 구조 일치성 확인
- 이동된 스크립트의 참조 관계 검증 및 수정
- Unity 메타 파일(.meta) 자동 업데이트 확인
- 프리팹, 씬, 스크립트 간 연결 상태 유지
- 이동 후 컴파일 오류 및 참조 오류 검사
- 필요 시 using 문과 네임스페이스 자동 수정
- 이동된 스크립트의 Inspector 설정 보존
- 게임 오브젝트와의 연결 상태 유지

## 🛡️ 안정성 및 품질 관리
- 모든 public 메서드는 매개변수 null 체크 후 ArgumentNullException 발생
- 예외 상황에 대한 명확한 처리 로직 구현
- 리소스 해제는 using문 또는 try-finally 사용
- 게임 상태 전환 시 안전한 초기화/정리
- 기능 구현을 우선으로 고려한 코드 작성
- Update() 메서드에서 필요한 기능만 구현
- 필요시에만 오브젝트 풀링 패턴 활용
- 수정 가능한 구조 설계

## 🚨 에러 처리 표준
- ArgumentNullException: null 매개변수 전달 시 발생
- InvalidOperationException: 잘못된 상태에서의 메서드 호출 시 발생
- GameLogger.Error(): 심각한 오류 상황 로깅
- GameLogger.Warning(): 경고 상황 및 예외적 상황 로깅
- GameLogger.Info(): 일반적인 정보성 로깅
- 예외 발생 시 사용자에게 적절한 피드백 제공
- 예외 상황 복구 로직 구현 (가능한 경우)
- 로그 레벨별 적절한 메시지 작성

## 🧪 테스트 전략 규칙
- 단위 테스트: 모든 Manager 클래스 필수 작성
- 통합 테스트: 시스템 간 연동 테스트 작성
- 테스트 커버리지: 핵심 로직 80% 이상 목표
- Mock 객체: 외부 의존성 분리를 위한 Mock 사용
- 테스트 네이밍: [메서드명]_[상황]_[예상결과] 형식 사용
- 테스트 데이터: 테스트용 ScriptableObject 활용
- 자동화 테스트: 빌드 시 자동 실행
- 테스트 환경: 개발 환경과 동일한 설정 사용

## 👥 코드 리뷰 프로세스
- 모든 코드는 최소 1명 이상 리뷰 필수
- 리뷰 포인트: 아키텍처 일관성, 네이밍 규칙, 예외 처리
- 리뷰 완료 후 머지 허용
- 리뷰어는 코드 작성자와 다른 팀원으로 지정
- 리뷰 시간: 일반 코드 24시간, 긴급 수정 4시간 내
- 리뷰 피드백: 구체적이고 건설적인 피드백 제공
- 리뷰 체크리스트: 프로젝트 룰 준수 여부 확인
- 리뷰 완료 기준: 모든 피드백 반영 또는 합의

## 🤖 AI 기반 룰 최적화 시스템
- 프로젝트 상황을 분석하여 룰 자동 조정
- 팀 역량과 개발 단계에 따른 룰 레벨 자동 선택
- 실시간 피드백 기반 룰 개선
- 기획 변경 시 룰 자동 업데이트
- 프로젝트 성숙도에 따른 룰 진화
- 상황별 룰 자동 적용 (프로토타입/개발/완성)
- 팀 피드백 기반 룰 커스터마이징
- 지속적인 룰 학습 및 개선