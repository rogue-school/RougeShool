---
alwaysApply: true
description: "RougeShool í”„ë¡œì íŠ¸ì—ì„œ ì‚¬ìš©í•˜ëŠ” ê³ ê¸‰ íŒ¨í„´ê³¼ ì „ë¬¸ ê¸°ë²•ì„ ì •ì˜í•©ë‹ˆë‹¤. DOTween Pro ê³ ê¸‰ íŒ¨í„´, Zenject DI ê³ ê¸‰ ë°”ì¸ë”©, ë¬¸ì„œí™” í‘œì¤€, ì„±ëŠ¥ ìµœì í™” ê¸°ë²•ì„ í¬í•¨í•©ë‹ˆë‹¤."
---
## ğŸ”§ Zenject DI ê³ ê¸‰ íŒ¨í„´

### ğŸ“‹ ê³ ê¸‰ ë°”ì¸ë”© íŒ¨í„´

#### **1. ì¡°ê±´ë¶€ ë°”ì¸ë”©**
```csharp
// ê²Œì„ ëª¨ë“œì— ë”°ë¥¸ ë‹¤ë¥¸ êµ¬í˜„ì²´ ë°”ì¸ë”©
public class GameModeInstaller : MonoInstaller
{
    [SerializeField] private GameMode currentGameMode;
    
    public override void InstallBindings()
    {
        switch (currentGameMode)
        {
            case GameMode.SinglePlayer:
                Container.Bind<ICombatManager>().To<SinglePlayerCombatManager>().AsSingle();
                break;
            case GameMode.MultiPlayer:
                Container.Bind<ICombatManager>().To<MultiPlayerCombatManager>().AsSingle();
                break;
        }
    }
}
```

#### **2. íŒ©í† ë¦¬ íŒ¨í„´ ê³ ê¸‰ í™œìš©**
```csharp
// ë³µì¡í•œ ê°ì²´ ìƒì„± íŒ©í† ë¦¬
public class SkillCardFactory
{
    private readonly DiContainer container;
    private readonly SkillCardDefinition[] cardDefinitions;
    
    public SkillCardFactory(DiContainer container, SkillCardDefinition[] definitions)
    {
        this.container = container;
        this.cardDefinitions = definitions;
    }
    
    public SkillCard CreateCard(string cardId, SkillCardRarity rarity)
    {
        var definition = cardDefinitions.FirstOrDefault(d => d.CardId == cardId);
        if (definition == null)
        {
            GameLogger.LogError($"ì¹´ë“œ ì •ì˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: {cardId}", GameLogger.LogCategory.Error);
            return null;
        }
        
        // Zenjectë¥¼ í†µí•œ ì˜ì¡´ì„± ì£¼ì…ìœ¼ë¡œ ì¹´ë“œ ìƒì„±
        return container.Instantiate<SkillCard>(new object[] { definition, rarity });
    }
}

// ë°”ì¸ë”©
Container.BindFactory<string, SkillCardRarity, SkillCard, SkillCardFactory.Factory>()
         .FromFactory<SkillCardFactory>();
```

#### **3. ìŠ¤ì½”í”„ ê´€ë¦¬ ê³ ê¸‰ íŒ¨í„´**
```csharp
// ì”¬ë³„ ìŠ¤ì½”í”„ ê´€ë¦¬
public class SceneScopeInstaller : MonoInstaller
{
    public override void InstallBindings()
    {
        // ì”¬ ìŠ¤ì½”í”„ - ì”¬ ì „í™˜ ì‹œ ìë™ í•´ì œ
        Container.Bind<ISceneManager>().To<SceneManager>().AsSingle();
        
        // ì „ì—­ ìŠ¤ì½”í”„ - ì”¬ ì „í™˜ ì‹œì—ë„ ìœ ì§€
        Container.Bind<IGlobalDataManager>().To<GlobalDataManager>().AsSingle().NonLazy();
        
        // ì„ì‹œ ìŠ¤ì½”í”„ - ëª…ì‹œì  í•´ì œ í•„ìš”
        Container.Bind<ITempDataManager>().To<TempDataManager>().AsTransient();
    }
}
```

### âš ï¸ Zenject ì‚¬ìš© ê¸ˆì§€ì‚¬í•­
- **ì ˆëŒ€ ê¸ˆì§€**: `Container.Bind<MonoBehaviour>()` - MonoBehaviourëŠ” ì§ì ‘ ë°”ì¸ë”© ê¸ˆì§€
- **ì ˆëŒ€ ê¸ˆì§€**: ìˆœí™˜ ì˜ì¡´ì„± ìƒì„±
- **ì£¼ì˜**: `NonLazy()` ì‚¬ìš© ì‹œ ì´ˆê¸°í™” ìˆœì„œ ê³ ë ¤ í•„ìˆ˜
- **ì£¼ì˜**: `AsTransient()` ì‚¬ìš© ì‹œ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì£¼ì˜

---

## ğŸ“š ë¬¸ì„œí™” ê³ ê¸‰ íŒ¨í„´

### ğŸ“‹ XML ë¬¸ì„œí™” í‘œì¤€

#### **1. í´ë˜ìŠ¤ ë¬¸ì„œí™”**
```csharp
/// <summary>
/// ì „íˆ¬ ì‹œìŠ¤í…œì˜ í•µì‹¬ ë§¤ë‹ˆì € í´ë˜ìŠ¤ì…ë‹ˆë‹¤.
/// í„´ ê´€ë¦¬, ì¹´ë“œ ì‹¤í–‰, ìŠ¬ë¡¯ ì´ë™ ë“±ì˜ ì „íˆ¬ ë¡œì§ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤.
/// </summary>
/// <remarks>
/// ì´ í´ë˜ìŠ¤ëŠ” ìƒˆë¡œìš´ 5ìŠ¬ë¡¯ ì‹œìŠ¤í…œì„ ê¸°ë°˜ìœ¼ë¡œ ë™ì‘í•©ë‹ˆë‹¤.
/// ê¸°ì¡´ 4ìŠ¬ë¡¯ ì‹œìŠ¤í…œê³¼ì˜ í˜¸í™˜ì„±ì„ ìœ„í•´ ë ˆê±°ì‹œ ë©”ì„œë“œë„ ì œê³µí•©ë‹ˆë‹¤.
/// </remarks>
/// <example>
/// <code>
/// var combatManager = FindObjectOfType&lt;CombatExecutionManager&gt;();
/// combatManager.ExecuteCardInBattleSlot();
/// combatManager.MoveSlotsForwardNew();
/// </code>
/// </example>
public class CombatExecutionManager : MonoBehaviour, ICoreSystemInitializable
{
    // êµ¬í˜„...
}
```

#### **2. ë©”ì„œë“œ ë¬¸ì„œí™”**
```csharp
/// <summary>
/// ì „íˆ¬ ìŠ¬ë¡¯ì—ì„œ ì¹´ë“œë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.
/// </summary>
/// <param name="slotPosition">ì‹¤í–‰í•  ìŠ¬ë¡¯ ìœ„ì¹˜</param>
/// <param name="executeImmediately">ì¦‰ì‹œ ì‹¤í–‰ ì—¬ë¶€ (ê¸°ë³¸ê°’: true)</param>
/// <returns>ì‹¤í–‰ ì„±ê³µ ì—¬ë¶€</returns>
/// <exception cref="System.InvalidOperationException">
/// ì „íˆ¬ í˜ì´ì¦ˆê°€ ì•„ë‹ ë•Œ ë°œìƒ
/// </exception>
/// <example>
/// <code>
/// bool success = ExecuteCardInSlot(CombatSlotPosition.BATTLE_SLOT_1, true);
/// if (success) {
///     GameLogger.LogInfo("ì¹´ë“œ ì‹¤í–‰ ì™„ë£Œ", GameLogger.LogCategory.Combat);
/// }
/// </code>
/// </example>
public bool ExecuteCardInSlot(CombatSlotPosition slotPosition, bool executeImmediately = true)
{
    // êµ¬í˜„...
}
```

### ğŸ“‹ ì£¼ì„ ì‘ì„± í‘œì¤€

#### **1. ë³µì¡í•œ ë¡œì§ ì£¼ì„**
```csharp
// ìƒˆë¡œìš´ 5ìŠ¬ë¡¯ ì‹œìŠ¤í…œì˜ ìŠ¬ë¡¯ ì´ë™ ë¡œì§
// ê¸°ì¡´ 4ìŠ¬ë¡¯ ì‹œìŠ¤í…œê³¼ì˜ í˜¸í™˜ì„±ì„ ìœ„í•´ ë³„ë„ ë©”ì„œë“œë¡œ ë¶„ë¦¬
private void MoveSlotsForwardNew()
{
    // 1ë‹¨ê³„: ëŒ€ê¸° ìŠ¬ë¡¯ì—ì„œ ì „íˆ¬ ìŠ¬ë¡¯ìœ¼ë¡œ ì´ë™
    // WAIT_SLOT_4 -> BATTLE_SLOT_1 (í”Œë ˆì´ì–´ ìš°ì„ )
    MoveCardFromWaitToBattle(CombatSlotPosition.WAIT_SLOT_4, CombatSlotPosition.BATTLE_SLOT_1);
    
    // 2ë‹¨ê³„: ë‚˜ë¨¸ì§€ ìŠ¬ë¡¯ë“¤ì„ ìˆœì°¨ì ìœ¼ë¡œ ì´ë™
    // WAIT_SLOT_3 -> WAIT_SLOT_4, WAIT_SLOT_2 -> WAIT_SLOT_3, ...
    for (int i = 3; i >= 1; i--)
    {
        var fromSlot = (CombatSlotPosition)(i + 3); // WAIT_SLOT_3, WAIT_SLOT_2, WAIT_SLOT_1
        var toSlot = (CombatSlotPosition)(i + 4);   // WAIT_SLOT_4, WAIT_SLOT_3, WAIT_SLOT_2
        MoveCardBetweenWaitSlots(fromSlot, toSlot);
    }
    
    // 3ë‹¨ê³„: ìƒˆë¡œìš´ ì¹´ë“œ ë“œë¡œìš° (í•„ìš”ì‹œ)
    if (ShouldDrawNewCard())
    {
        DrawCardToWaitSlot(CombatSlotPosition.WAIT_SLOT_1);
    }
}
```

#### **2. ì„±ëŠ¥ ìµœì í™” ì£¼ì„**
```csharp
// ì„±ëŠ¥ ìµœì í™”: ì˜¤ë¸Œì íŠ¸ í’€ë§ì„ ì‚¬ìš©í•œ ì¹´ë“œ ìƒì„±
// ë§¤ í”„ë ˆì„ë§ˆë‹¤ ìƒˆ ì¹´ë“œë¥¼ ìƒì„±í•˜ëŠ” ëŒ€ì‹  ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì¹´ë“œ í’€ì—ì„œ ê°€ì ¸ì˜´
private SkillCard GetCardFromPool()
{
    // í’€ì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•œ ì¹´ë“œ ì°¾ê¸°
    var availableCard = cardPool.FirstOrDefault(card => !card.gameObject.activeInHierarchy);
    
    if (availableCard == null)
    {
        // í’€ì´ ë¶€ì¡±í•œ ê²½ìš°ì—ë§Œ ìƒˆë¡œ ìƒì„± (ìµœëŒ€ 50ê°œ ì œí•œ)
        if (cardPool.Count < 50)
        {
            availableCard = CreateNewCard();
            cardPool.Add(availableCard);
        }
        else
        {
            GameLogger.LogWarning("ì¹´ë“œ í’€ í•œê³„ ë„ë‹¬", GameLogger.LogCategory.Performance);
            return null;
        }
    }
    
    return availableCard;
}
```

---

## ğŸš€ ì„±ëŠ¥ ìµœì í™” ê³ ê¸‰ ê¸°ë²•

### ğŸ“‹ ë©”ëª¨ë¦¬ ê´€ë¦¬ íŒ¨í„´

#### **1. ì˜¤ë¸Œì íŠ¸ í’€ë§ ê³ ê¸‰ í™œìš©**
```csharp
public class AdvancedObjectPool<T> where T : MonoBehaviour
{
    private Queue<T> pool = new Queue<T>();
    private HashSet<T> activeObjects = new HashSet<T>();
    private int maxPoolSize = 100;
    
    public T Get()
    {
        T obj;
        if (pool.Count > 0)
        {
            obj = pool.Dequeue();
        }
        else
        {
            obj = CreateNewObject();
        }
        
        activeObjects.Add(obj);
        obj.gameObject.SetActive(true);
        return obj;
    }
    
    public void Return(T obj)
    {
        if (activeObjects.Contains(obj))
        {
            activeObjects.Remove(obj);
            obj.gameObject.SetActive(false);
            
            if (pool.Count < maxPoolSize)
            {
                pool.Enqueue(obj);
            }
            else
            {
                Object.Destroy(obj.gameObject);
            }
        }
    }
}
```

#### **2. ìºì‹± ì „ëµ**
```csharp
public class CachedDataManager : MonoBehaviour
{
    private Dictionary<string, object> cache = new Dictionary<string, object>();
    private float cacheExpiryTime = 300f; // 5ë¶„
    
    public T GetCachedData<T>(string key, Func<T> dataProvider)
    {
        if (cache.ContainsKey(key))
        {
            return (T)cache[key];
        }
        
        T data = dataProvider();
        cache[key] = data;
        
        // ìºì‹œ ë§Œë£Œ ìŠ¤ì¼€ì¤„ë§
        StartCoroutine(ExpireCacheAfterDelay(key));
        
        return data;
    }
    
    private IEnumerator ExpireCacheAfterDelay(string key)
    {
        yield return new WaitForSeconds(cacheExpiryTime);
        cache.Remove(key);
    }
}
```

### âš ï¸ ì„±ëŠ¥ ìµœì í™” ì£¼ì˜ì‚¬í•­
- **ì ˆëŒ€ ê¸ˆì§€**: ë§¤ í”„ë ˆì„ `FindObjectOfType` í˜¸ì¶œ
- **ì ˆëŒ€ ê¸ˆì§€**: ë¬´ì œí•œ ì˜¤ë¸Œì íŠ¸ ìƒì„±
- **ì£¼ì˜**: ìºì‹œ í¬ê¸° ì œí•œ í•„ìˆ˜
- **ì£¼ì˜**: ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ëª¨ë‹ˆí„°ë§ í•„ìˆ˜

---

## ğŸ” ë””ë²„ê¹… ê³ ê¸‰ ê¸°ë²•

### ğŸ“‹ ë¡œê¹… ì „ëµ
```csharp
// ì»¨í…ìŠ¤íŠ¸ë³„ ë¡œê¹… ë ˆë²¨ ê´€ë¦¬
public static class AdvancedLogging
{
    public static void LogCombatAction(string action, params object[] parameters)
    {
        if (GameLogger.IsLogLevelEnabled(GameLogger.LogCategory.Combat))
        {
            string message = string.Format(action, parameters);
            GameLogger.LogInfo($"[ì „íˆ¬] {message}", GameLogger.LogCategory.Combat);
        }
    }
    
    public static void LogPerformanceMetric(string operation, float duration)
    {
        if (duration > 0.016f) // 60fps ê¸°ì¤€
        {
            GameLogger.LogWarning($"ì„±ëŠ¥ ì´ìŠˆ ê°ì§€: {operation} ({duration:F3}ì´ˆ)", GameLogger.LogCategory.Performance);
        }
    }
}
```

---

## ğŸ“‹ ì²´í¬ë¦¬ìŠ¤íŠ¸

### âœ… ê³ ê¸‰ íŒ¨í„´ ì ìš© ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] DOTween ì• ë‹ˆë©”ì´ì…˜ì— ì ì ˆí•œ Ease ì„¤ì • ì ìš©
- [ ] Zenject ë°”ì¸ë”©ì— ì ì ˆí•œ ìŠ¤ì½”í”„ ì„¤ì •
- [ ] ë³µì¡í•œ ë¡œì§ì— ìƒì„¸í•œ ì£¼ì„ ì‘ì„±
- [ ] ì„±ëŠ¥ ìµœì í™” ê¸°ë²• ì ìš© (í’€ë§, ìºì‹±)
- [ ] XML ë¬¸ì„œí™” ì™„ë£Œ
- [ ] ë””ë²„ê¹… ë¡œê·¸ ì ì ˆíˆ ì„¤ì •
- [ ] ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€ ì½”ë“œ ì ìš©

### âš ï¸ ê¸ˆì§€ì‚¬í•­ ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] DOTween.KillAll() ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
- [ ] ë¬´í•œ ë£¨í”„ ì• ë‹ˆë©”ì´ì…˜ ì—†ìŒ
- [ ] MonoBehaviour ì§ì ‘ ë°”ì¸ë”© ì—†ìŒ
- [ ] ìˆœí™˜ ì˜ì¡´ì„± ì—†ìŒ
- [ ] ë§¤ í”„ë ˆì„ FindObjectOfType í˜¸ì¶œ ì—†ìŒ
- [ ] ë¬´ì œí•œ ì˜¤ë¸Œì íŠ¸ ìƒì„± ì—†ìŒ