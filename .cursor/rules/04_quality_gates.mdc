---
alwaysApply: true
description: "AI-사용자 협업을 위한 코드 품질 게이트. 아키텍처 설계 원칙, 성능 최적화 기준, AI 협업 프로세스를 포함합니다."
---
## 🎯 AI-사용자 협업 품질 게이트

### 📋 **코드 생성 체크리스트**

#### **1. 아키텍처 설계 원칙 (SOLID)**
- [ ] **단일 책임 원칙 (SRP)**: 클래스당 하나의 변경 이유만 존재
- [ ] **개방-폐쇄 원칙 (OCP)**: 확장에는 열려있고 수정에는 닫혀있음
- [ ] **리스코프 치환 원칙 (LSP)**: 하위 타입은 상위 타입을 완전히 대체 가능
- [ ] **인터페이스 분리 원칙 (ISP)**: 클라이언트는 사용하지 않는 인터페이스에 의존하지 않음
- [ ] **의존성 역전 원칙 (DIP)**: 구체 클래스가 아닌 추상에 의존

#### **2. 코드 품질 검증**
- [ ] **null 안전성**: 모든 public 메서드에서 null 체크 및 예외 처리
- [ ] **복잡도 제한**: 순환 복잡도 5 이하, 인지 복잡도 7 이하
- [ ] **테스트 가능성**: 모든 외부 의존성 주입으로 관리
- [ ] **한국어 표준**: 모든 사용자 메시지, 로그, 문서가 한국어
- [ ] **Inspector 한글화**: Header, Tooltip, 필드명이 한국어로 작성
- [ ] **XML 문서화**: public API에 완전한 XML 문서화

#### **3. Unity 성능 최적화**
- [ ] **메모리 관리**: 매 프레임 할당량 < 1KB, GC 압박 최소화
- [ ] **렌더링 최적화**: Draw Call 100개 이하, 배치 처리 적용
- [ ] **스크립트 최적화**: Update() 금지, 이벤트 기반 처리 필수
- [ ] **오브젝트 풀링**: 자주 생성/삭제되는 객체 필수 적용
- [ ] **캐싱 전략**: 반복 계산 결과 캐싱 (최대 5초 TTL)

#### **4. 프로젝트 특화 검증**
- [ ] **Zenject DI**: 적절한 바인딩과 스코프 설정, 순환 의존성 없음
- [ ] **DOTween Pro**: 애니메이션 완료 시 정리 코드 포함
- [ ] **CoreSystem**: ICoreSystemInitializable 구현 확인
- [ ] **기존 코드 우선**: 새로운 기능보다 기존 코드 개선 우선
- [ ] **이벤트 생명주기**: OnEnable/OnDisable에서 이벤트 구독/해제

---

## 📊 품질 메트릭 기준

### 🎯 **아키텍처 설계 기준**
```csharp
// SOLID 원칙 준수
public interface ICardValidator
{
    bool CanPlayCard(SkillCard card, IPlayer player);
}

public class CardValidator : ICardValidator
{
    public bool CanPlayCard(SkillCard card, IPlayer player)
    {
        if (card == null) return false;
        if (!card.IsAvailable) return false;
        if (player.CurrentMana < card.ManaCost) return false;
        
        return true;
    }
}

// 의존성 주입으로 테스트 가능
public class CardProcessor
{
    private readonly ICardValidator validator;
    private readonly IAudioManager audioManager;
    
    public CardProcessor(ICardValidator validator, IAudioManager audioManager)
    {
        this.validator = validator ?? throw new ArgumentNullException(nameof(validator));
        this.audioManager = audioManager ?? throw new ArgumentNullException(nameof(audioManager));
    }
    
    public bool ProcessCard(SkillCard card, IPlayer player)
    {
        if (!validator.CanPlayCard(card, player))
        {
            GameLogger.LogWarning($"카드 사용 불가: {card?.CardName}", GameLogger.LogCategory.Combat);
            return false;
        }
        
        audioManager.PlaySFX(card.UseSound);
        GameLogger.LogInfo($"카드 사용: {card.CardName}", GameLogger.LogCategory.Combat);
        return true;
    }
}
```

### 🎯 **성능 최적화 기준**
```csharp
// 메모리 효율적 오브젝트 풀링
public class CardPool : MonoBehaviour
{
    private Queue<SkillCard> availableCards = new Queue<SkillCard>();
    private HashSet<SkillCard> activeCards = new HashSet<SkillCard>();
    
    public SkillCard GetCard()
    {
        SkillCard card;
        if (availableCards.Count > 0)
        {
            card = availableCards.Dequeue();
        }
        else
        {
            card = Instantiate(cardPrefab, transform);
        }
        
        activeCards.Add(card);
        card.gameObject.SetActive(true);
        return card;
    }
    
    public void ReturnCard(SkillCard card)
    {
        if (activeCards.Remove(card))
        {
            card.gameObject.SetActive(false);
            availableCards.Enqueue(card);
        }
    }
}
```

---

## 🤖 AI-사용자 협업 프로세스

### 📋 **AI 코드 생성 워크플로우**
```markdown
1. 요구사항 분석 단계
   ├── 사용자 요청 명확화
   ├── 기존 코드 검색 및 분석
   ├── 아키텍처 패턴 식별
   └── 재사용 가능성 평가

2. 설계 단계
   ├── SOLID 원칙 적용 검토
   ├── 의존성 그래프 설계
   ├── 인터페이스 정의
   └── 성능 영향 분석

3. 구현 단계
   ├── 단위 테스트 가능한 구조
   ├── 예외 처리 완비
   ├── 한국어 로깅 구현
   └── XML 문서화 완료

4. 검증 단계
   ├── 컴파일 오류 0 확인
   ├── 품질 게이트 통과
   ├── 기존 코드와의 일관성 확인
   └── 사용자 피드백 반영
```

### 📋 **사용자 피드백 처리 규칙**
```markdown
피드백 유형별 대응:
├── 버그 리포트 → 즉시 수정, 원인 분석 제공
├── 성능 이슈 → 프로파일링 결과와 함께 최적화 방안 제시
├── 아키텍처 개선 → SOLID 원칙 기반 리팩토링 제안
├── 기능 추가 → 기존 패턴 유지하며 확장성 고려
└── 코드 리뷰 → 개발자 관점에서 개선점 제시
```

### 📋 **코드 리뷰 체크리스트**
```markdown
생성된 코드 리뷰 시 확인사항:
├── 아키텍처 일관성: 프로젝트 패턴과 일치하는가?
├── 성능 영향: 메모리 할당, GC 압박 최소화되었는가?
├── 테스트 가능성: 모든 의존성이 주입 가능한가?
├── 확장성: 새로운 요구사항에 유연하게 대응 가능한가?
├── 유지보수성: 다른 개발자가 쉽게 이해할 수 있는가?
└── 문서화: API 사용법이 명확히 문서화되었는가?
```

---

## 🚫 절대 금지사항

### 🔴 **런타임 에러 위험**
- null 참조 예외 가능성
- 배열/리스트 인덱스 초과
- 타입 캐스팅 실패 가능성
- 무한 루프 가능성

### 🔴 **메모리 누수 위험**
- 이벤트 구독 해제 누락
- DOTween 애니메이션 정리 누락
- 오브젝트 풀링 미사용
- 캐시 크기 제한 없음

### 🔴 **성능 저하 위험**
- 매 프레임 FindObjectOfType 호출
- 매 프레임 무거운 계산
- 불필요한 오브젝트 생성
- 메모리 할당 최적화 부족

### 🔴 **아키텍처 위반**
- SOLID 원칙 위반
- 의존성 역전 원칙 위반
- 단일 책임 원칙 위반
- 기존 코드 중복 생성

---

## 🔧 품질 검증 도구

### 📋 **자동 검증 스크립트**
```csharp
// 코드 품질 자동 검증을 위한 확장 메서드
public static class QualityValidationExtensions
{
    public static bool ValidateNullSafety(this object obj, string objectName)
    {
        if (obj == null)
        {
            GameLogger.LogError($"{objectName}이 null입니다", GameLogger.LogCategory.Error);
            return false;
        }
        return true;
    }
    
    public static bool ValidateComponent<T>(this GameObject gameObject) where T : Component
    {
        var component = gameObject.GetComponent<T>();
        if (component == null)
        {
            GameLogger.LogError($"{gameObject.name}에 {typeof(T).Name} 컴포넌트가 없습니다", GameLogger.LogCategory.Error);
            return false;
        }
        return true;
    }
}
```

### 📋 **성능 모니터링**
```csharp
public class PerformanceMonitor : MonoBehaviour
{
    private Dictionary<string, float> operationTimes = new Dictionary<string, float>();
    
    public void StartOperation(string operationName)
    {
        operationTimes[operationName] = Time.realtimeSinceStartup;
    }
    
    public void EndOperation(string operationName)
    {
        if (operationTimes.ContainsKey(operationName))
        {
            float duration = Time.realtimeSinceStartup - operationTimes[operationName];
            
            if (duration > 0.016f) // 60fps 기준
            {
                GameLogger.LogWarning($"성능 이슈: {operationName} ({duration:F3}초)", GameLogger.LogCategory.Performance);
            }
            
            operationTimes.Remove(operationName);
        }
    }
}
```

---

## 📋 최종 검증 체크리스트

### ✅ **코드 제출 전 필수 확인사항**
- [ ] 모든 public 메서드에 null 체크 적용
- [ ] 모든 예외 상황에 대한 처리 완료
- [ ] GameLogger를 통한 적절한 로깅 완료
- [ ] 한국어 메시지 및 문서화 완료
- [ ] Unity Inspector 한글화 완료 (Header, Tooltip, 필드명)
- [ ] XML 문서화 완료
- [ ] 성능 최적화 기법 적용
- [ ] 메모리 누수 방지 코드 적용
- [ ] 기존 코드와의 일관성 확인
- [ ] SOLID 원칙 준수 확인
- [ ] 테스트 가능한 구조로 설계

### ⚠️ **자동 거부 기준**
- 런타임 에러 위험이 있는 코드
- 메모리 누수 가능성이 있는 코드
- 심각한 성능 이슈가 있는 코드
- 아키텍처 원칙을 위반하는 코드
- 기존 코드와 중복되는 기능

---

## 🎯 품질 목표

### 📊 **정량적 목표**
- **코드 커버리지**: 최소 90% 이상
- **순환 복잡도**: 메서드당 최대 5 이하
- **메모리 사용량**: 씬당 최대 200MB 이하
- **프레임 레이트**: 최소 60fps 유지
- **로딩 시간**: 씬 전환 2초 이하
- **GC 압박**: 매 프레임 할당량 1KB 이하

### 📊 **정성적 목표**
- **아키텍처 일관성**: SOLID 원칙 100% 준수
- **테스트 가능성**: 모든 외부 의존성 주입으로 관리
- **확장성**: 새로운 기능 추가 시 기존 코드 수정 최소화
- **유지보수성**: 다른 개발자가 5분 내 이해 가능
- **문서화 완성도**: API 사용법이 코드만으로도 명확

### 📊 **AI 협업 품질 목표**
- **요구사항 이해도**: 사용자 의도 95% 이상 정확히 파악
- **코드 재사용률**: 기존 코드 활용률 80% 이상
- **일관성 유지**: 프로젝트 패턴과 100% 일치
- **피드백 반영**: 사용자 피드백 1회 내 완전 반영